
Velha2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000030  00800100  000028a6  0000293a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000028a6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000036  00800130  00800130  0000296a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000296a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000299c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000078  00000000  00000000  000029dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000e4b  00000000  00000000  00002a54  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000240  00000000  00000000  0000389f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000534  00000000  00000000  00003adf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000230  00000000  00000000  00004014  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000002d1  00000000  00000000  00004244  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000dd6  00000000  00000000  00004515  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000c8  00000000  00000000  000052eb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <__ctors_end>
       4:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
       8:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
       c:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      10:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      14:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      18:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      1c:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      20:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      24:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      28:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      2c:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      30:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      34:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      38:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      3c:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      40:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      44:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      48:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      4c:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      50:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      54:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      58:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      5c:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      60:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>
      64:	0c 94 bb 0e 	jmp	0x1d76	; 0x1d76 <__bad_interrupt>

00000068 <JOG4>:
	...
      f4:	09 00 09 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     14c:	00 00 09 06 00 06 00 00 00 00 00 00 00 00 00 00     ................
	...
     170:	00 00 09 00 09 06 00 00 00 00 00 00 00 00 00 00     ................
	...
     208:	00 07 00 00 04 07 00 00 00 00 08 00 00 08 04 00     ................
     218:	00 03 02 00 00 00 00 03 00 00 00 00 00 00 00 00     ................
	...
     234:	03 02 00 00 00 00 03 00 00 03 02 03 00 00 00 00     ................
	...
     27c:	00 08 00 00 00 00 09 08 00 00 00 00 00 00 00 00     ................
	...
     2a8:	00 00 00 07 00 07 04 00 00 00 00 00 07 00 07 04     ................
     2b8:	00 00 00 03 02 00 00 03 00 00 00 00 00 00 00 00     ................
     2c8:	00 00 00 00 00 07 00 07 00 00 04 00 00 00 06 06     ................
     2d8:	00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     2fc:	07 00 07 04 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     37c:	08 00 06 06 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     42c:	00 00 08 00 00 04 04 00 00 00 00 00 00 00 00 00     ................
	...
     480:	00 07 08 07 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     50c:	00 00 00 09 00 00 00 09 08 00 00 00 00 00 00 00     ................
	...
     52c:	08 00 06 06 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     544:	00 00 00 09 00 09 08 00 00 00 00 00 00 00 00 00     ................
     554:	04 00 00 01 00 00 00 01 00 00 00 00 00 00 00 00     ................
     564:	00 00 06 00 00 06 00 01 00 00 00 04 00 00 01 00     ................
     574:	04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     590:	00 00 00 03 00 01 00 00 00 03 00 00 00 00 00 00     ................
	...
     5dc:	00 00 08 00 00 04 04 00 00 00 06 00 00 03 00 03     ................
	...
     5f8:	00 07 00 00 08 07 00 00 00 06 06 00 03 00 00 00     ................
     608:	00 00 04 03 00 04 00 00 00 00 00 00 00 00 00 00     ................
	...
     65c:	07 00 00 04 00 04 00 00 00 00 00 00 00 00 00 00     ................
	...
     6b4:	00 00 07 00 00 08 07 00 00 00 00 00 00 00 00 00     ................
	...
     710:	00 00 08 00 06 08 00 00 00 00 00 09 00 09 06 00     ................
	...
     738:	00 00 02 01 00 00 00 00 00 01 00 00 00 00 00 00     ................
     748:	00 00 00 00 02 01 00 00 00 01 00 00 00 02 01 00     ................
     758:	00 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     7b0:	00 00 07 00 00 04 07 00 00 00 00 00 00 00 00 00     ................
	...
     82c:	00 02 01 00 00 00 00 00 01 00 00 00 00 00 00 00     ................
	...
     854:	09 00 09 00 00 06 00 00 00 09 00 09 00 00 06 00     ................
	...
     86c:	00 09 00 00 00 09 00 00 06 00 00 00 00 00 00 00     ................
     87c:	00 00 02 01 00 01 00 00 00 00 00 00 00 00 00 00     ................
	...
     898:	00 04 04 00 02 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     8bc:	00 08 00 00 00 00 00 08 07 00 00 00 00 00 00 00     ................
	...
     908:	00 00 08 00 06 08 00 00 00 00 00 00 00 00 00 00     ................
	...
     98c:	00 00 06 00 00 03 00 03 00 00 00 00 00 00 08 00     ................
     99c:	06 08 00 00 00 00 00 09 00 09 06 00 00 00 00 00     ................
	...
     9c0:	00 00 08 08 00 00 00 00 00 01 00 00 00 00 00 00     ................
     9d0:	00 00 00 00 02 01 00 00 00 01 00 00 00 02 01 00     ................
     9e0:	00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     ac4:	00 00 00 07 00 00 00 00 00 01 00 01 00 00 00 00     ................
	...
     b20:	00 00 06 02 00 00 02 00 00 00 00 00 00 00 00 00     ................
	...
     b3c:	00 09 00 00 00 09 00 00 06 00 00 00 00 00 00 00     ................
	...
     b88:	00 07 08 07 00 00 08 00 00 00 00 08 07 00 00 00     ................
	...
     ba8:	00 07 00 00 00 00 02 02 00 00 06 03 00 00 03 00     ................
     bb8:	00 00 00 03 06 00 00 03 00 00 00 00 00 00 00 00     ................
	...
     c30:	00 00 09 00 09 00 00 04 00 00 07 00 00 00 03 00     ................
     c40:	07 00 00 00 00 00 00 00 00 00 00 00 07 00 00 00     ................
     c50:	03 00 07 00 00 00 06 00 04 00 00 06 00 00 00 00     ................
     c60:	00 00 00 00 00 00 00 04 06 00 04 00 00 00 00 00     ................
	...
     c88:	00 00 08 00 00 00 00 00 02 08 00 00 00 00 00 00     ................
	...
     cc8:	00 00 07 00 00 00 03 00 03 00 08 00 00 00 00 00     ................
     cd8:	02 08 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
     cf4:	00 00 09 00 00 00 00 00 09 02 00 00 07 00 00 00     ................
     d04:	03 00 03 00 08 00 00 00 00 02 02 00 00 00 00 00     ................
	...
     d98:	08 00 00 00 00 00 02 02 00 00 00 00 00 00 00 00     ................
	...
     dbc:	00 00 06 00 04 00 00 06 00 00 00 00 00 00 00 00     ................
	...
     e18:	06 00 04 00 00 04 00 00 00 00 00 00 00 00 00 00     ................
	...
     e70:	08 02 00 00 00 00 02 00 00 00 00 00 00 00 00 00     ................
	...
     eb0:	00 07 00 00 04 07 00 00 00 00 08 00 00 08 04 00     ................
     ec0:	00 08 08 00 00 00 00 03 00 00 00 00 00 00 00 00     ................
	...
     edc:	03 02 00 00 00 00 02 00 00 03 02 03 00 00 00 00     ................
	...
     f2c:	04 00 00 01 00 00 00 01 00 00 00 00 00 00 00 00     ................
	...
     f48:	00 00 08 00 00 08 04 00 00 00 00 00 00 00 00 00     ................
	...
     fa0:	00 09 00 09 00 00 00 00 00 03 00 00 00 00 00 00     ................
	...
    108c:	08 00 00 00 00 00 09 08 00 00 00 09 00 00 00 09     ................
    109c:	08 00 00 00 00 00 00 00 00 00 00 09 00 00 00 00     ................
    10ac:	00 02 02 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    10c8:	00 00 04 01 00 01 00 00 00 00 00 02 04 00 02 00     ................
    10d8:	00 00 00 00 00 07 00 07 00 00 04 00 00 00 00 00     ................
	...
    1160:	00 00 00 02 04 00 02 00 00 00 00 00 00 00 00 00     ................
	...
    11ac:	03 02 00 00 00 00 00 02 00 00 00 00 00 00 00 00     ................
	...
    11d4:	08 00 06 06 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    11ec:	00 00 00 09 00 09 08 00 00 00 00 00 00 00 00 00     ................
    11fc:	04 00 00 01 00 00 00 01 00 00 00 00 00 00 00 00     ................
    120c:	00 00 04 00 00 01 00 01 00 00 00 04 00 00 01 00     ................
    121c:	01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    123c:	09 00 00 00 00 00 09 08 00 00 00 00 00 00 00 00     ................
	...
    128c:	00 09 00 00 00 00 00 09 08 00 00 00 00 00 00 00     ................
	...
    12b8:	00 00 03 06 00 00 03 00 00 00 00 00 00 00 00 00     ................
	...
    1314:	09 00 00 00 00 00 09 08 00 00 00 09 00 00 00 09     ................
    1324:	08 00 00 00 00 00 00 00 00 00 00 09 00 00 00 00     ................
    1334:	00 09 08 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1350:	00 00 04 01 00 01 00 00 00 00 00 02 04 00 02 00     ................
	...
    13b4:	00 00 03 02 00 00 03 00 00 00 00 00 00 00 00 00     ................
	...
    140c:	00 00 00 06 00 06 00 00 03 00 00 00 00 00 00 00     ................
	...
    1460:	00 00 00 06 00 07 06 00 00 00 00 00 07 00 04 04     ................
    1470:	00 00 00 03 02 00 00 03 00 00 00 00 00 00 00 00     ................
    1480:	00 00 00 00 00 07 00 07 00 00 04 00 00 00 06 06     ................
    1490:	00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    14d4:	00 00 00 07 00 00 00 09 00 07 00 00 00 00 00 00     ................
	...
    14fc:	06 00 09 00 00 06 00 00 00 09 00 04 00 00 04 00     ................
	...
    1514:	00 09 00 00 00 09 00 00 06 00 00 00 00 00 00 00     ................
    1524:	00 00 02 01 00 01 00 00 00 00 00 00 00 00 00 00     ................
	...
    1540:	00 04 04 00 02 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    155c:	02 01 00 00 00 01 00 00 00 00 00 00 00 00 00 00     ................
	...
    15ec:	00 03 02 03 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    163c:	00 00 06 06 00 00 02 00 00 00 00 00 00 00 00 00     ................
	...
    16f0:	00 04 04 00 02 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1770:	00 06 03 00 03 00 00 00 00 00 00 00 00 00 00 00     ................
	...
    1794:	00 00 08 00 00 04 04 00 00 00 06 00 00 03 00 03     ................
	...
    17b0:	00 07 00 00 08 07 00 00 00 06 03 00 03 00 00 00     ................
    17c0:	00 00 06 03 00 03 00 00 00 00 00 00 00 00 00 00     ................
	...
    17ec:	00 02 01 00 00 00 00 02 00 00 00 00 00 00 00 00     ................
	...
    1830:	00 07 08 07 00 00 07 00 00 00 00 08 07 00 00 00     ................
	...
    1850:	00 07 00 00 00 00 08 07 00 00 06 02 00 00 02 00     ................
    1860:	00 00 00 03 06 00 00 03 00 00 00 00 00 00 00 00     ................
	...
    18f8:	00 00 00 04 01 00 01 00 00 00 00 00 00 00 00 00     ................
	...
    191c:	00 00 00 04 00 04 01 00 00 00 00 00 00 00 00 00     ................
	...
    1978:	00 02 01 00 01 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00001a09 <JOG3>:
	...
    1a15:	07 00 07 04 07 07 00 00 00 08 00 08 08 04 08 00     ................
    1a25:	03 02 00 00 03 00 03 03 00 00 00 00 00 00 00 00     ................
    1a35:	00 00 03 02 07 00 00 04 07 00 00 06 06 00 00 02     ................
    1a45:	00 06 06 00 03 02 07 00 03 04 00 00 00 03 02 02     ................
    1a55:	00 02 02 00 00 00 00 00 07 00 07 04 07 07 00 00     ................
	...
    1a6d:	00 00 09 00 09 09 09 06 00 00 09 00 00 09 09 09     ................
    1a7d:	03 00 00 00 00 00 00 00 00 00 07 00 00 07 00 00     ................
    1a8d:	01 07 07 04 00 00 01 00 09 00 09 08 04 00 04 09     ................
    1a9d:	00 00 04 00 04 00 00 06 07 00 03 08 07 00 00 00     ................
    1aad:	00 08 00 08 08 06 08 00 00 00 09 00 09 09 09 06     ................
	...
    1ac5:	00 02 01 00 00 00 09 00 09 06 00 00 00 00 00 00     ................
    1ad5:	00 00 00 02 01 00 01 00 00 01 01 00 06 06 00 00     ................
    1ae5:	00 09 00 06 06 02 01 00 01 00 09 00 00 06 04 04     ................
    1af5:	00 02 00 00 04 04 00 00 03 02 00 00 03 00 03 03     ................
    1b05:	00 00 09 00 00 09 09 09 07 02 01 00 00 00 09 00     ................
    1b15:	09 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
    1b25:	00 00 00 00 08 00 08 00 00 00 08 03 08 00 09 09     ................
    1b35:	00 00 09 00 09 08 03 03 01 00 00 03 00 00 03 00     ................
    1b45:	03 06 00 00 03 08 07 00 00 00 00 00 00 00 00 00     ................
    1b55:	00 00 00 07 06 00 04 03 00 07 00 04 00 06 00 04     ................
    1b65:	00 04 04 00 08 07 00 00 00 03 02 03 00 00 00 00     ................
    1b75:	00 00 00 00 00 00 07 07 00 00 00 03 07 07 00 08     ................
    1b85:	00 02 00 02 00 02 02 00 00 07 03 00 03 03 00 03     ................
    1b95:	00 04 04 06 00 04 00 04 00 00 03 02 07 00 00 04     ................
    1ba5:	07 00 07 00 00 07 00 00 09 07 07 02 01 00 01 00     ................
    1bb5:	00 01 01 00 02 07 02 00 00 00 02 00 02 00 00 00     ................
	...
    1bd1:	00 00 00 04 01 00 01 00 00 00 09 08 03 01 01 01     ................
    1be1:	00 00 01 00 00 07 07 00 07 00 00 08 07 00 00 06     ................
    1bf1:	06 00 00 08 00 06 06 04 00 00 01 00 09 00 09 08     ................
    1c01:	04 04 00 01 00 00 00 04 04 00 09 09 00 00 09 00     ................
    1c11:	09 08 00 00 00 00 00 00 00 00 00 04 01 00 01 00     ................
    1c21:	00 00 09 08 00 00 00 00 00 00 00 00 00 04 01 01     ................
    1c31:	01 00 01 00 00 00 02 04 02 02 00 02 00 00 00 00     ................
    1c41:	03 02 07 00 03 04 00 00 06 00 06 00 00 01 06 00     ................
    1c51:	06 02 01 00 01 00 09 00 00 06 03 03 09 00 00 03     ................
    1c61:	00 00 03 00 00 00 00 00 00 00 00 00 07 01 01 01     ................
    1c71:	00 00 01 00 00 04 01 01 01 00 01 00 00 00 00 00     ................
    1c81:	00 00 00 00 00 00 00 03 03 06 03 00 03 00 00 00     ................
    1c91:	00 00 08 08 00 08 08 07 00 00 00 06 07 00 03 08     ................
    1ca1:	07 00 04 04 00 08 00 00 04 04 00 00 03 06 00 00     ................
    1cb1:	03 08 07 00 00 00 00 00 00 00 00 00 00 07 07 00     ................
    1cc1:	07 00 00 08 07 00 02 06 02 02 00 02 00 00 00 03     ................
    1cd1:	03 06 03 00 03 00 00 00 00 00 00 00 00 00 00 00     ................
	...

00001ce2 <JOG2>:
    1ce2:	00 03 02 07 00 09 04 09 08 03 00 01 01 00 03 03     ................
    1cf2:	06 01 02 01 00 07 00 09 04 07 06 07 01 07 00 00     ................
    1d02:	02 01 07 01 00 08 07 06 00 04 03 02 07 09 03 09     ................
    1d12:	08 00 00 03 09 03 04 03 06 01 00 03 00 09 08 09     ................
    1d22:	04 07 07 00 09 09 00 07 02 01 06 01 00 03 08 07     ................
	...

00001d33 <JOG1>:
    1d33:	05 05 05 05 01 05 05 05 05                          .........

00001d3c <__ctors_end>:
    1d3c:	11 24       	eor	r1, r1
    1d3e:	1f be       	out	0x3f, r1	; 63
    1d40:	cf ef       	ldi	r28, 0xFF	; 255
    1d42:	d8 e0       	ldi	r29, 0x08	; 8
    1d44:	de bf       	out	0x3e, r29	; 62
    1d46:	cd bf       	out	0x3d, r28	; 61

00001d48 <__do_copy_data>:
    1d48:	11 e0       	ldi	r17, 0x01	; 1
    1d4a:	a0 e0       	ldi	r26, 0x00	; 0
    1d4c:	b1 e0       	ldi	r27, 0x01	; 1
    1d4e:	e6 ea       	ldi	r30, 0xA6	; 166
    1d50:	f8 e2       	ldi	r31, 0x28	; 40
    1d52:	02 c0       	rjmp	.+4      	; 0x1d58 <__do_copy_data+0x10>
    1d54:	05 90       	lpm	r0, Z+
    1d56:	0d 92       	st	X+, r0
    1d58:	a0 33       	cpi	r26, 0x30	; 48
    1d5a:	b1 07       	cpc	r27, r17
    1d5c:	d9 f7       	brne	.-10     	; 0x1d54 <__do_copy_data+0xc>

00001d5e <__do_clear_bss>:
    1d5e:	21 e0       	ldi	r18, 0x01	; 1
    1d60:	a0 e3       	ldi	r26, 0x30	; 48
    1d62:	b1 e0       	ldi	r27, 0x01	; 1
    1d64:	01 c0       	rjmp	.+2      	; 0x1d68 <.do_clear_bss_start>

00001d66 <.do_clear_bss_loop>:
    1d66:	1d 92       	st	X+, r1

00001d68 <.do_clear_bss_start>:
    1d68:	a6 36       	cpi	r26, 0x66	; 102
    1d6a:	b2 07       	cpc	r27, r18
    1d6c:	e1 f7       	brne	.-8      	; 0x1d66 <.do_clear_bss_loop>
    1d6e:	0e 94 1a 14 	call	0x2834	; 0x2834 <main>
    1d72:	0c 94 51 14 	jmp	0x28a2	; 0x28a2 <_exit>

00001d76 <__bad_interrupt>:
    1d76:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00001d7a <atualizar_display>:
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
}
void atualizar_display(){
    1d7a:	cf 92       	push	r12
    1d7c:	df 92       	push	r13
    1d7e:	ef 92       	push	r14
    1d80:	ff 92       	push	r15
	uint8_t i;
	uint32_t dado = 0, shift;
	if(leds[0][0]&LED_X)dado |= 1UL<<19;
    1d82:	80 91 39 01 	lds	r24, 0x0139
    1d86:	80 ff       	sbrs	r24, 0
    1d88:	06 c0       	rjmp	.+12     	; 0x1d96 <atualizar_display+0x1c>
    1d8a:	c1 2c       	mov	r12, r1
    1d8c:	d1 2c       	mov	r13, r1
    1d8e:	76 01       	movw	r14, r12
    1d90:	68 94       	set
    1d92:	e3 f8       	bld	r14, 3
    1d94:	03 c0       	rjmp	.+6      	; 0x1d9c <atualizar_display+0x22>
inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
}
void atualizar_display(){
	uint8_t i;
	uint32_t dado = 0, shift;
    1d96:	c1 2c       	mov	r12, r1
    1d98:	d1 2c       	mov	r13, r1
    1d9a:	76 01       	movw	r14, r12
	if(leds[0][0]&LED_X)dado |= 1UL<<19;
	if(leds[0][0]&LED_O)dado |= 1UL<<18;
    1d9c:	81 ff       	sbrs	r24, 1
    1d9e:	02 c0       	rjmp	.+4      	; 0x1da4 <atualizar_display+0x2a>
    1da0:	68 94       	set
    1da2:	e2 f8       	bld	r14, 2
	if(leds[0][1]&LED_X)dado |= 1UL<<11;
    1da4:	80 91 3a 01 	lds	r24, 0x013A
    1da8:	80 ff       	sbrs	r24, 0
    1daa:	02 c0       	rjmp	.+4      	; 0x1db0 <atualizar_display+0x36>
    1dac:	68 94       	set
    1dae:	d3 f8       	bld	r13, 3
	if(leds[0][1]&LED_O)dado |= 1UL<<10;
    1db0:	81 ff       	sbrs	r24, 1
    1db2:	02 c0       	rjmp	.+4      	; 0x1db8 <atualizar_display+0x3e>
    1db4:	68 94       	set
    1db6:	d2 f8       	bld	r13, 2
	if(leds[0][2]&LED_X)dado |= 1UL<<3;
    1db8:	80 91 3b 01 	lds	r24, 0x013B
    1dbc:	80 ff       	sbrs	r24, 0
    1dbe:	02 c0       	rjmp	.+4      	; 0x1dc4 <atualizar_display+0x4a>
    1dc0:	68 94       	set
    1dc2:	c3 f8       	bld	r12, 3
	if(leds[0][2]&LED_O)dado |= 1UL<<2;
    1dc4:	81 ff       	sbrs	r24, 1
    1dc6:	02 c0       	rjmp	.+4      	; 0x1dcc <atualizar_display+0x52>
    1dc8:	68 94       	set
    1dca:	c2 f8       	bld	r12, 2
	if(leds[1][0]&LED_X)dado |= 1UL<<17;
    1dcc:	80 91 3c 01 	lds	r24, 0x013C
    1dd0:	80 ff       	sbrs	r24, 0
    1dd2:	02 c0       	rjmp	.+4      	; 0x1dd8 <atualizar_display+0x5e>
    1dd4:	68 94       	set
    1dd6:	e1 f8       	bld	r14, 1
	if(leds[1][0]&LED_O)dado |= 1UL<<21;
    1dd8:	81 ff       	sbrs	r24, 1
    1dda:	02 c0       	rjmp	.+4      	; 0x1de0 <atualizar_display+0x66>
    1ddc:	68 94       	set
    1dde:	e5 f8       	bld	r14, 5
	if(leds[1][1]&LED_X)dado |= 1UL<<9;
    1de0:	80 91 3d 01 	lds	r24, 0x013D
    1de4:	80 ff       	sbrs	r24, 0
    1de6:	02 c0       	rjmp	.+4      	; 0x1dec <atualizar_display+0x72>
    1de8:	68 94       	set
    1dea:	d1 f8       	bld	r13, 1
	if(leds[1][1]&LED_O)dado |= 1UL<<13;
    1dec:	81 ff       	sbrs	r24, 1
    1dee:	02 c0       	rjmp	.+4      	; 0x1df4 <atualizar_display+0x7a>
    1df0:	68 94       	set
    1df2:	d5 f8       	bld	r13, 5
	if(leds[1][2]&LED_X)dado |= 1UL<<1;
    1df4:	80 91 3e 01 	lds	r24, 0x013E
    1df8:	80 ff       	sbrs	r24, 0
    1dfa:	02 c0       	rjmp	.+4      	; 0x1e00 <atualizar_display+0x86>
    1dfc:	68 94       	set
    1dfe:	c1 f8       	bld	r12, 1
	if(leds[1][2]&LED_O)dado |= 1UL<<5;
    1e00:	81 ff       	sbrs	r24, 1
    1e02:	02 c0       	rjmp	.+4      	; 0x1e08 <atualizar_display+0x8e>
    1e04:	68 94       	set
    1e06:	c5 f8       	bld	r12, 5
	if(leds[2][0]&LED_X)dado |= 1UL<<16;
    1e08:	80 91 3f 01 	lds	r24, 0x013F
    1e0c:	80 ff       	sbrs	r24, 0
    1e0e:	02 c0       	rjmp	.+4      	; 0x1e14 <atualizar_display+0x9a>
    1e10:	68 94       	set
    1e12:	e0 f8       	bld	r14, 0
	if(leds[2][0]&LED_O)dado |= 1UL<<20;
    1e14:	81 ff       	sbrs	r24, 1
    1e16:	02 c0       	rjmp	.+4      	; 0x1e1c <atualizar_display+0xa2>
    1e18:	68 94       	set
    1e1a:	e4 f8       	bld	r14, 4
	if(leds[2][1]&LED_X)dado |= 1UL<<8;
    1e1c:	80 91 40 01 	lds	r24, 0x0140
    1e20:	80 ff       	sbrs	r24, 0
    1e22:	02 c0       	rjmp	.+4      	; 0x1e28 <atualizar_display+0xae>
    1e24:	68 94       	set
    1e26:	d0 f8       	bld	r13, 0
	if(leds[2][1]&LED_O)dado |= 1UL<<12;
    1e28:	81 ff       	sbrs	r24, 1
    1e2a:	02 c0       	rjmp	.+4      	; 0x1e30 <atualizar_display+0xb6>
    1e2c:	68 94       	set
    1e2e:	d4 f8       	bld	r13, 4
	if(leds[2][2]&LED_X)dado |= 1UL<<0;
    1e30:	80 91 41 01 	lds	r24, 0x0141
    1e34:	80 ff       	sbrs	r24, 0
    1e36:	02 c0       	rjmp	.+4      	; 0x1e3c <atualizar_display+0xc2>
    1e38:	68 94       	set
    1e3a:	c0 f8       	bld	r12, 0
	if(leds[2][2]&LED_O)dado |= 1UL<<4;
    1e3c:	81 ff       	sbrs	r24, 1
    1e3e:	02 c0       	rjmp	.+4      	; 0x1e44 <atualizar_display+0xca>
    1e40:	68 94       	set
    1e42:	c4 f8       	bld	r12, 4
	PORTD &= ~((1<<CLOCK)|(1<<STROBE)|(1<<DATA));
    1e44:	8b b1       	in	r24, 0x0b	; 11
    1e46:	88 7f       	andi	r24, 0xF8	; 248
    1e48:	8b b9       	out	0x0b, r24	; 11
    1e4a:	28 e1       	ldi	r18, 0x18	; 24
	for(shift=1,i=0 ; i<24 ; i++,shift<<=1){
    1e4c:	81 e0       	ldi	r24, 0x01	; 1
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	a0 e0       	ldi	r26, 0x00	; 0
    1e52:	b0 e0       	ldi	r27, 0x00	; 0
		if((dado&shift)!=0)PORTD |= (1<<DATA);
    1e54:	ac 01       	movw	r20, r24
    1e56:	bd 01       	movw	r22, r26
    1e58:	4c 21       	and	r20, r12
    1e5a:	5d 21       	and	r21, r13
    1e5c:	6e 21       	and	r22, r14
    1e5e:	7f 21       	and	r23, r15
    1e60:	45 2b       	or	r20, r21
    1e62:	46 2b       	or	r20, r22
    1e64:	47 2b       	or	r20, r23
    1e66:	11 f0       	breq	.+4      	; 0x1e6c <atualizar_display+0xf2>
    1e68:	58 9a       	sbi	0x0b, 0	; 11
    1e6a:	01 c0       	rjmp	.+2      	; 0x1e6e <atualizar_display+0xf4>
		else               PORTD &=~(1<<DATA);
    1e6c:	58 98       	cbi	0x0b, 0	; 11
		_NOP();
    1e6e:	00 00       	nop
		PORTD |= (1<<CLOCK);
    1e70:	5a 9a       	sbi	0x0b, 2	; 11
		_NOP();
    1e72:	00 00       	nop
		PORTD &=~(1<<CLOCK);
    1e74:	5a 98       	cbi	0x0b, 2	; 11
	if(leds[2][1]&LED_X)dado |= 1UL<<8;
	if(leds[2][1]&LED_O)dado |= 1UL<<12;
	if(leds[2][2]&LED_X)dado |= 1UL<<0;
	if(leds[2][2]&LED_O)dado |= 1UL<<4;
	PORTD &= ~((1<<CLOCK)|(1<<STROBE)|(1<<DATA));
	for(shift=1,i=0 ; i<24 ; i++,shift<<=1){
    1e76:	88 0f       	add	r24, r24
    1e78:	99 1f       	adc	r25, r25
    1e7a:	aa 1f       	adc	r26, r26
    1e7c:	bb 1f       	adc	r27, r27
    1e7e:	21 50       	subi	r18, 0x01	; 1
    1e80:	49 f7       	brne	.-46     	; 0x1e54 <atualizar_display+0xda>
		_NOP();
		PORTD |= (1<<CLOCK);
		_NOP();
		PORTD &=~(1<<CLOCK);
	}
	PORTD |= (1<<STROBE);
    1e82:	59 9a       	sbi	0x0b, 1	; 11
	_NOP();
    1e84:	00 00       	nop
	_NOP();
    1e86:	00 00       	nop
	PORTD &=~(1<<STROBE);
    1e88:	59 98       	cbi	0x0b, 1	; 11
}
    1e8a:	ff 90       	pop	r15
    1e8c:	ef 90       	pop	r14
    1e8e:	df 90       	pop	r13
    1e90:	cf 90       	pop	r12
    1e92:	08 95       	ret

00001e94 <adc>:
uint16_t adc(uint8_t porta){
	ADMUX = (1<<REFS0)|(porta&0x0F);
    1e94:	8f 70       	andi	r24, 0x0F	; 15
    1e96:	80 64       	ori	r24, 0x40	; 64
    1e98:	80 93 7c 00 	sts	0x007C, r24
	_NOP();
    1e9c:	00 00       	nop
	ADCSRA |= (1<<ADSC);
    1e9e:	ea e7       	ldi	r30, 0x7A	; 122
    1ea0:	f0 e0       	ldi	r31, 0x00	; 0
    1ea2:	80 81       	ld	r24, Z
    1ea4:	80 64       	ori	r24, 0x40	; 64
    1ea6:	80 83       	st	Z, r24
	while(ADCSRA&(1<<ADSC));
    1ea8:	80 81       	ld	r24, Z
    1eaa:	86 fd       	sbrc	r24, 6
    1eac:	fd cf       	rjmp	.-6      	; 0x1ea8 <adc+0x14>
	return ADC;
    1eae:	80 91 78 00 	lds	r24, 0x0078
    1eb2:	90 91 79 00 	lds	r25, 0x0079
}
    1eb6:	08 95       	ret

00001eb8 <determinar_estados>:
void determinar_estados(){
    1eb8:	af 92       	push	r10
    1eba:	bf 92       	push	r11
    1ebc:	df 92       	push	r13
    1ebe:	ef 92       	push	r14
    1ec0:	ff 92       	push	r15
    1ec2:	0f 93       	push	r16
    1ec4:	1f 93       	push	r17
    1ec6:	cf 93       	push	r28
    1ec8:	df 93       	push	r29
    1eca:	02 e4       	ldi	r16, 0x42	; 66
    1ecc:	11 e0       	ldi	r17, 0x01	; 1
    1ece:	84 e5       	ldi	r24, 0x54	; 84
    1ed0:	91 e0       	ldi	r25, 0x01	; 1
    1ed2:	f8 01       	movw	r30, r16
	uint8_t i;
	for(i=0;i<9;i++)valores[i] = 0;
    1ed4:	11 92       	st	Z+, r1
    1ed6:	11 92       	st	Z+, r1
    1ed8:	e8 17       	cp	r30, r24
    1eda:	f9 07       	cpc	r31, r25
    1edc:	d9 f7       	brne	.-10     	; 0x1ed4 <determinar_estados+0x1c>
    1ede:	68 94       	set
    1ee0:	ff 24       	eor	r15, r15
    1ee2:	f3 f8       	bld	r15, 3
	for(i=0;i<8;i++){
		PORTD &=~(1<<ANALOG);
		valores[2] += adc(0);
    1ee4:	c2 e4       	ldi	r28, 0x42	; 66
    1ee6:	d1 e0       	ldi	r29, 0x01	; 1
}
void determinar_estados(){
	uint8_t i;
	for(i=0;i<9;i++)valores[i] = 0;
	for(i=0;i<8;i++){
		PORTD &=~(1<<ANALOG);
    1ee8:	5b 98       	cbi	0x0b, 3	; 11
		valores[2] += adc(0);
    1eea:	80 e0       	ldi	r24, 0x00	; 0
    1eec:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1ef0:	2c 81       	ldd	r18, Y+4	; 0x04
    1ef2:	3d 81       	ldd	r19, Y+5	; 0x05
    1ef4:	82 0f       	add	r24, r18
    1ef6:	93 1f       	adc	r25, r19
    1ef8:	9d 83       	std	Y+5, r25	; 0x05
    1efa:	8c 83       	std	Y+4, r24	; 0x04
		valores[3] += adc(3);
    1efc:	83 e0       	ldi	r24, 0x03	; 3
    1efe:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f02:	2e 81       	ldd	r18, Y+6	; 0x06
    1f04:	3f 81       	ldd	r19, Y+7	; 0x07
    1f06:	82 0f       	add	r24, r18
    1f08:	93 1f       	adc	r25, r19
    1f0a:	9f 83       	std	Y+7, r25	; 0x07
    1f0c:	8e 83       	std	Y+6, r24	; 0x06
		valores[4] += adc(4);
    1f0e:	84 e0       	ldi	r24, 0x04	; 4
    1f10:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f14:	28 85       	ldd	r18, Y+8	; 0x08
    1f16:	39 85       	ldd	r19, Y+9	; 0x09
    1f18:	82 0f       	add	r24, r18
    1f1a:	93 1f       	adc	r25, r19
    1f1c:	99 87       	std	Y+9, r25	; 0x09
    1f1e:	88 87       	std	Y+8, r24	; 0x08
		valores[6] += adc(5);
    1f20:	85 e0       	ldi	r24, 0x05	; 5
    1f22:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f26:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f28:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f2a:	82 0f       	add	r24, r18
    1f2c:	93 1f       	adc	r25, r19
    1f2e:	9d 87       	std	Y+13, r25	; 0x0d
    1f30:	8c 87       	std	Y+12, r24	; 0x0c
		PORTD |= (1<<ANALOG);
    1f32:	5b 9a       	sbi	0x0b, 3	; 11
		valores[5] += adc(1);
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f3a:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f3c:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f3e:	82 0f       	add	r24, r18
    1f40:	93 1f       	adc	r25, r19
    1f42:	9b 87       	std	Y+11, r25	; 0x0b
    1f44:	8a 87       	std	Y+10, r24	; 0x0a
		valores[8] += adc(2);
    1f46:	82 e0       	ldi	r24, 0x02	; 2
    1f48:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f4c:	28 89       	ldd	r18, Y+16	; 0x10
    1f4e:	39 89       	ldd	r19, Y+17	; 0x11
    1f50:	82 0f       	add	r24, r18
    1f52:	93 1f       	adc	r25, r19
    1f54:	99 8b       	std	Y+17, r25	; 0x11
    1f56:	88 8b       	std	Y+16, r24	; 0x10
		valores[0] += adc(3);
    1f58:	83 e0       	ldi	r24, 0x03	; 3
    1f5a:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f5e:	28 81       	ld	r18, Y
    1f60:	39 81       	ldd	r19, Y+1	; 0x01
    1f62:	82 0f       	add	r24, r18
    1f64:	93 1f       	adc	r25, r19
    1f66:	99 83       	std	Y+1, r25	; 0x01
    1f68:	88 83       	st	Y, r24
		valores[1] += adc(4);
    1f6a:	84 e0       	ldi	r24, 0x04	; 4
    1f6c:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f70:	2a 81       	ldd	r18, Y+2	; 0x02
    1f72:	3b 81       	ldd	r19, Y+3	; 0x03
    1f74:	82 0f       	add	r24, r18
    1f76:	93 1f       	adc	r25, r19
    1f78:	9b 83       	std	Y+3, r25	; 0x03
    1f7a:	8a 83       	std	Y+2, r24	; 0x02
		valores[7] += adc(5);
    1f7c:	85 e0       	ldi	r24, 0x05	; 5
    1f7e:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    1f82:	2e 85       	ldd	r18, Y+14	; 0x0e
    1f84:	3f 85       	ldd	r19, Y+15	; 0x0f
    1f86:	82 0f       	add	r24, r18
    1f88:	93 1f       	adc	r25, r19
    1f8a:	9f 87       	std	Y+15, r25	; 0x0f
    1f8c:	8e 87       	std	Y+14, r24	; 0x0e
    1f8e:	fa 94       	dec	r15
	return ADC;
}
void determinar_estados(){
	uint8_t i;
	for(i=0;i<9;i++)valores[i] = 0;
	for(i=0;i<8;i++){
    1f90:	f1 10       	cpse	r15, r1
    1f92:	aa cf       	rjmp	.-172    	; 0x1ee8 <determinar_estados+0x30>
    1f94:	a0 e3       	ldi	r26, 0x30	; 48
    1f96:	b1 e0       	ldi	r27, 0x01	; 1
    1f98:	e4 e5       	ldi	r30, 0x54	; 84
    1f9a:	f1 e0       	ldi	r31, 0x01	; 1
    1f9c:	0f 2e       	mov	r0, r31
    1f9e:	f0 e0       	ldi	r31, 0x00	; 0
    1fa0:	af 2e       	mov	r10, r31
    1fa2:	f1 e0       	ldi	r31, 0x01	; 1
    1fa4:	bf 2e       	mov	r11, r31
    1fa6:	f0 2d       	mov	r31, r0
    1fa8:	0f 2e       	mov	r0, r31
    1faa:	f9 e3       	ldi	r31, 0x39	; 57
    1fac:	ef 2e       	mov	r14, r31
    1fae:	f1 e0       	ldi	r31, 0x01	; 1
    1fb0:	ff 2e       	mov	r15, r31
    1fb2:	f0 2d       	mov	r31, r0
				estados[i]=0;
				bastioes[i] = valores[i]-thresholds[i];
			}
		}else{
			if(valores[i]<bastioes[i]){
				estados[i]=1;
    1fb4:	dd 24       	eor	r13, r13
    1fb6:	d3 94       	inc	r13
    1fb8:	98 01       	movw	r18, r16
		valores[0] += adc(3);
		valores[1] += adc(4);
		valores[7] += adc(5);
	}
	for(i=0;i<9;i++){
		valores[i]/=8;
    1fba:	e8 01       	movw	r28, r16
    1fbc:	88 81       	ld	r24, Y
    1fbe:	99 81       	ldd	r25, Y+1	; 0x01
    1fc0:	99 23       	and	r25, r25
    1fc2:	0c f4       	brge	.+2      	; 0x1fc6 <determinar_estados+0x10e>
    1fc4:	07 96       	adiw	r24, 0x07	; 7
    1fc6:	95 95       	asr	r25
    1fc8:	87 95       	ror	r24
    1fca:	95 95       	asr	r25
    1fcc:	87 95       	ror	r24
    1fce:	95 95       	asr	r25
    1fd0:	87 95       	ror	r24
    1fd2:	e9 01       	movw	r28, r18
    1fd4:	99 83       	std	Y+1, r25	; 0x01
    1fd6:	88 83       	st	Y, r24
    1fd8:	0e 5f       	subi	r16, 0xFE	; 254
    1fda:	1f 4f       	sbci	r17, 0xFF	; 255
		
		/*
		if(valores[i]>bastioes[i])estados[i]=0;
		else                      estados[i]=1;
		*/
		if(estados[i]){
    1fdc:	2c 91       	ld	r18, X
    1fde:	22 23       	and	r18, r18
    1fe0:	79 f0       	breq	.+30     	; 0x2000 <determinar_estados+0x148>
			if(valores[i]>bastioes[i]){
    1fe2:	20 81       	ld	r18, Z
    1fe4:	31 81       	ldd	r19, Z+1	; 0x01
    1fe6:	28 17       	cp	r18, r24
    1fe8:	39 07       	cpc	r19, r25
    1fea:	c4 f4       	brge	.+48     	; 0x201c <determinar_estados+0x164>
				estados[i]=0;
    1fec:	1c 92       	st	X, r1
				bastioes[i] = valores[i]-thresholds[i];
    1fee:	e5 01       	movw	r28, r10
    1ff0:	28 81       	ld	r18, Y
    1ff2:	39 81       	ldd	r19, Y+1	; 0x01
    1ff4:	ac 01       	movw	r20, r24
    1ff6:	42 1b       	sub	r20, r18
    1ff8:	53 0b       	sbc	r21, r19
    1ffa:	51 83       	std	Z+1, r21	; 0x01
    1ffc:	40 83       	st	Z, r20
    1ffe:	0e c0       	rjmp	.+28     	; 0x201c <determinar_estados+0x164>
			}
		}else{
			if(valores[i]<bastioes[i]){
    2000:	20 81       	ld	r18, Z
    2002:	31 81       	ldd	r19, Z+1	; 0x01
    2004:	82 17       	cp	r24, r18
    2006:	93 07       	cpc	r25, r19
    2008:	4c f4       	brge	.+18     	; 0x201c <determinar_estados+0x164>
				estados[i]=1;
    200a:	ed 01       	movw	r28, r26
    200c:	d8 82       	st	Y, r13
				bastioes[i] = valores[i]+thresholds[i];
    200e:	e5 01       	movw	r28, r10
    2010:	28 81       	ld	r18, Y
    2012:	39 81       	ldd	r19, Y+1	; 0x01
    2014:	28 0f       	add	r18, r24
    2016:	39 1f       	adc	r19, r25
    2018:	31 83       	std	Z+1, r19	; 0x01
    201a:	20 83       	st	Z, r18
    201c:	bf 01       	movw	r22, r30
			}
		}
		if(valores[i]>(bastioes[i]+thresholds[i]))bastioes[i]=valores[i]-thresholds[i];
    201e:	e5 01       	movw	r28, r10
    2020:	29 91       	ld	r18, Y+
    2022:	39 91       	ld	r19, Y+
    2024:	5e 01       	movw	r10, r28
    2026:	40 81       	ld	r20, Z
    2028:	51 81       	ldd	r21, Z+1	; 0x01
    202a:	42 0f       	add	r20, r18
    202c:	53 1f       	adc	r21, r19
    202e:	48 17       	cp	r20, r24
    2030:	59 07       	cpc	r21, r25
    2032:	2c f4       	brge	.+10     	; 0x203e <determinar_estados+0x186>
    2034:	ac 01       	movw	r20, r24
    2036:	42 1b       	sub	r20, r18
    2038:	53 0b       	sbc	r21, r19
    203a:	51 83       	std	Z+1, r21	; 0x01
    203c:	40 83       	st	Z, r20
		if(valores[i]<(bastioes[i]-thresholds[i]))bastioes[i]=valores[i]+thresholds[i];
    203e:	eb 01       	movw	r28, r22
    2040:	48 81       	ld	r20, Y
    2042:	59 81       	ldd	r21, Y+1	; 0x01
    2044:	42 1b       	sub	r20, r18
    2046:	53 0b       	sbc	r21, r19
    2048:	84 17       	cp	r24, r20
    204a:	95 07       	cpc	r25, r21
    204c:	24 f4       	brge	.+8      	; 0x2056 <determinar_estados+0x19e>
    204e:	82 0f       	add	r24, r18
    2050:	93 1f       	adc	r25, r19
    2052:	99 83       	std	Y+1, r25	; 0x01
    2054:	88 83       	st	Y, r24
    2056:	11 96       	adiw	r26, 0x01	; 1
    2058:	32 96       	adiw	r30, 0x02	; 2
		valores[8] += adc(2);
		valores[0] += adc(3);
		valores[1] += adc(4);
		valores[7] += adc(5);
	}
	for(i=0;i<9;i++){
    205a:	ae 15       	cp	r26, r14
    205c:	bf 05       	cpc	r27, r15
    205e:	09 f0       	breq	.+2      	; 0x2062 <determinar_estados+0x1aa>
    2060:	ab cf       	rjmp	.-170    	; 0x1fb8 <determinar_estados+0x100>
			}
		}
		if(valores[i]>(bastioes[i]+thresholds[i]))bastioes[i]=valores[i]-thresholds[i];
		if(valores[i]<(bastioes[i]-thresholds[i]))bastioes[i]=valores[i]+thresholds[i];
	}
}
    2062:	df 91       	pop	r29
    2064:	cf 91       	pop	r28
    2066:	1f 91       	pop	r17
    2068:	0f 91       	pop	r16
    206a:	ff 90       	pop	r15
    206c:	ef 90       	pop	r14
    206e:	df 90       	pop	r13
    2070:	bf 90       	pop	r11
    2072:	af 90       	pop	r10
    2074:	08 95       	ret

00002076 <init_hardware>:
void init_hardware(){
    2076:	cf 93       	push	r28
    2078:	df 93       	push	r29
	DDRD |= (1<<ANALOG)|(1<<CLOCK)|(1<<STROBE)|(1<<DATA);
    207a:	8a b1       	in	r24, 0x0a	; 10
    207c:	8f 60       	ori	r24, 0x0F	; 15
    207e:	8a b9       	out	0x0a, r24	; 10
	PORTD &= ~((1<<ANALOG)|(1<<CLOCK)|(1<<STROBE)|(1<<DATA));
    2080:	8b b1       	in	r24, 0x0b	; 11
    2082:	80 7f       	andi	r24, 0xF0	; 240
    2084:	8b b9       	out	0x0b, r24	; 11
#define PRE 150
int16_t valores[9], bastioes[9], thresholds[9]={PRE,100,PRE,PRE,100,PRE,PRE,PRE,PRE};
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
    2086:	80 e0       	ldi	r24, 0x00	; 0
    2088:	90 e0       	ldi	r25, 0x00	; 0
    208a:	e0 91 12 01 	lds	r30, 0x0112
    208e:	f0 91 13 01 	lds	r31, 0x0113
    2092:	e8 0f       	add	r30, r24
    2094:	f9 1f       	adc	r31, r25
    2096:	10 82       	st	Z, r1
    2098:	01 96       	adiw	r24, 0x01	; 1
    209a:	89 30       	cpi	r24, 0x09	; 9
    209c:	91 05       	cpc	r25, r1
    209e:	a9 f7       	brne	.-22     	; 0x208a <init_hardware+0x14>
}
void init_hardware(){
	DDRD |= (1<<ANALOG)|(1<<CLOCK)|(1<<STROBE)|(1<<DATA);
	PORTD &= ~((1<<ANALOG)|(1<<CLOCK)|(1<<STROBE)|(1<<DATA));
	apagar();
	atualizar_display();
    20a0:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
	DDRC = 0;
    20a4:	17 b8       	out	0x07, r1	; 7
	ADMUX = (1<<REFS0);
    20a6:	80 e4       	ldi	r24, 0x40	; 64
    20a8:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = (1<<ADEN)|(0b00000110);
    20ac:	86 e8       	ldi	r24, 0x86	; 134
    20ae:	80 93 7a 00 	sts	0x007A, r24
	ADCSRB = 0;
    20b2:	10 92 7b 00 	sts	0x007B, r1
	DIDR0 = 0b00111111;
    20b6:	8f e3       	ldi	r24, 0x3F	; 63
    20b8:	80 93 7e 00 	sts	0x007E, r24
	
	PORTD &=~(1<<ANALOG);
    20bc:	5b 98       	cbi	0x0b, 3	; 11
	valores[2] = adc(0);
    20be:	80 e0       	ldi	r24, 0x00	; 0
    20c0:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    20c4:	c2 e4       	ldi	r28, 0x42	; 66
    20c6:	d1 e0       	ldi	r29, 0x01	; 1
    20c8:	9d 83       	std	Y+5, r25	; 0x05
    20ca:	8c 83       	std	Y+4, r24	; 0x04
	valores[3] = adc(3);
    20cc:	83 e0       	ldi	r24, 0x03	; 3
    20ce:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    20d2:	9f 83       	std	Y+7, r25	; 0x07
    20d4:	8e 83       	std	Y+6, r24	; 0x06
	valores[4] = adc(4);
    20d6:	84 e0       	ldi	r24, 0x04	; 4
    20d8:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    20dc:	99 87       	std	Y+9, r25	; 0x09
    20de:	88 87       	std	Y+8, r24	; 0x08
	valores[6] = adc(5);
    20e0:	85 e0       	ldi	r24, 0x05	; 5
    20e2:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    20e6:	9d 87       	std	Y+13, r25	; 0x0d
    20e8:	8c 87       	std	Y+12, r24	; 0x0c
	PORTD |= (1<<ANALOG);
    20ea:	5b 9a       	sbi	0x0b, 3	; 11
	valores[5] = adc(1);
    20ec:	81 e0       	ldi	r24, 0x01	; 1
    20ee:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    20f2:	9b 87       	std	Y+11, r25	; 0x0b
    20f4:	8a 87       	std	Y+10, r24	; 0x0a
	valores[8] = adc(2);
    20f6:	82 e0       	ldi	r24, 0x02	; 2
    20f8:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    20fc:	99 8b       	std	Y+17, r25	; 0x11
    20fe:	88 8b       	std	Y+16, r24	; 0x10
	valores[0] = adc(3);
    2100:	83 e0       	ldi	r24, 0x03	; 3
    2102:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    2106:	99 83       	std	Y+1, r25	; 0x01
    2108:	88 83       	st	Y, r24
	valores[1] = adc(4);
    210a:	84 e0       	ldi	r24, 0x04	; 4
    210c:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    2110:	9b 83       	std	Y+3, r25	; 0x03
    2112:	8a 83       	std	Y+2, r24	; 0x02
	valores[7] = adc(5);
    2114:	85 e0       	ldi	r24, 0x05	; 5
    2116:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <adc>
    211a:	9f 87       	std	Y+15, r25	; 0x0f
    211c:	8e 87       	std	Y+14, r24	; 0x0e
    211e:	fe 01       	movw	r30, r28
    2120:	c0 e0       	ldi	r28, 0x00	; 0
    2122:	d1 e0       	ldi	r29, 0x01	; 1
    2124:	a4 e5       	ldi	r26, 0x54	; 84
    2126:	b1 e0       	ldi	r27, 0x01	; 1
    2128:	44 e5       	ldi	r20, 0x54	; 84
    212a:	51 e0       	ldi	r21, 0x01	; 1
	for(uint8_t i=0;i<9;i++)bastioes[i]=valores[i]-thresholds[i];
    212c:	81 91       	ld	r24, Z+
    212e:	91 91       	ld	r25, Z+
    2130:	29 91       	ld	r18, Y+
    2132:	39 91       	ld	r19, Y+
    2134:	82 1b       	sub	r24, r18
    2136:	93 0b       	sbc	r25, r19
    2138:	8d 93       	st	X+, r24
    213a:	9d 93       	st	X+, r25
    213c:	e4 17       	cp	r30, r20
    213e:	f5 07       	cpc	r31, r21
    2140:	a9 f7       	brne	.-22     	; 0x212c <init_hardware+0xb6>
}
    2142:	df 91       	pop	r29
    2144:	cf 91       	pop	r28
    2146:	08 95       	ret

00002148 <setup_and_test>:
void setup_and_test(){
    2148:	ff 92       	push	r15
    214a:	0f 93       	push	r16
    214c:	1f 93       	push	r17
    214e:	cf 93       	push	r28
    2150:	df 93       	push	r29
#define PRE 150
int16_t valores[9], bastioes[9], thresholds[9]={PRE,100,PRE,PRE,100,PRE,PRE,PRE,PRE};
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
    2152:	80 e0       	ldi	r24, 0x00	; 0
    2154:	90 e0       	ldi	r25, 0x00	; 0
    2156:	e0 91 12 01 	lds	r30, 0x0112
    215a:	f0 91 13 01 	lds	r31, 0x0113
    215e:	e8 0f       	add	r30, r24
    2160:	f9 1f       	adc	r31, r25
    2162:	10 82       	st	Z, r1
    2164:	01 96       	adiw	r24, 0x01	; 1
    2166:	89 30       	cpi	r24, 0x09	; 9
    2168:	91 05       	cpc	r25, r1
    216a:	a9 f7       	brne	.-22     	; 0x2156 <setup_and_test+0xe>
	valores[7] = adc(5);
	for(uint8_t i=0;i<9;i++)bastioes[i]=valores[i]-thresholds[i];
}
void setup_and_test(){
	apagar();
	atualizar_display();
    216c:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    2170:	c0 e0       	ldi	r28, 0x00	; 0
    2172:	d0 e0       	ldi	r29, 0x00	; 0
	for(uint8_t i=0;i<9;i++){
		leds_l[i] = LED_X;
    2174:	ff 24       	eor	r15, r15
    2176:	f3 94       	inc	r15
#define PRE 150
int16_t valores[9], bastioes[9], thresholds[9]={PRE,100,PRE,PRE,100,PRE,PRE,PRE,PRE};
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
    2178:	00 e0       	ldi	r16, 0x00	; 0
    217a:	10 e0       	ldi	r17, 0x00	; 0
}
void setup_and_test(){
	apagar();
	atualizar_display();
	for(uint8_t i=0;i<9;i++){
		leds_l[i] = LED_X;
    217c:	e0 91 12 01 	lds	r30, 0x0112
    2180:	f0 91 13 01 	lds	r31, 0x0113
    2184:	ec 0f       	add	r30, r28
    2186:	fd 1f       	adc	r31, r29
    2188:	f0 82       	st	Z, r15
		atualizar_display();
    218a:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    218e:	2f e7       	ldi	r18, 0x7F	; 127
    2190:	88 e3       	ldi	r24, 0x38	; 56
    2192:	91 e0       	ldi	r25, 0x01	; 1
    2194:	21 50       	subi	r18, 0x01	; 1
    2196:	80 40       	sbci	r24, 0x00	; 0
    2198:	90 40       	sbci	r25, 0x00	; 0
    219a:	e1 f7       	brne	.-8      	; 0x2194 <setup_and_test+0x4c>
    219c:	00 c0       	rjmp	.+0      	; 0x219e <setup_and_test+0x56>
    219e:	00 00       	nop
		_delay_ms(50);
		determinar_estados();
    21a0:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
#define PRE 150
int16_t valores[9], bastioes[9], thresholds[9]={PRE,100,PRE,PRE,100,PRE,PRE,PRE,PRE};
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
    21a4:	80 2f       	mov	r24, r16
    21a6:	91 2f       	mov	r25, r17
    21a8:	e0 91 12 01 	lds	r30, 0x0112
    21ac:	f0 91 13 01 	lds	r31, 0x0113
    21b0:	e8 0f       	add	r30, r24
    21b2:	f9 1f       	adc	r31, r25
    21b4:	10 82       	st	Z, r1
    21b6:	01 96       	adiw	r24, 0x01	; 1
    21b8:	89 30       	cpi	r24, 0x09	; 9
    21ba:	91 05       	cpc	r25, r1
    21bc:	a9 f7       	brne	.-22     	; 0x21a8 <setup_and_test+0x60>
		leds_l[i] = LED_X;
		atualizar_display();
		_delay_ms(50);
		determinar_estados();
		apagar();
		atualizar_display();
    21be:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    21c2:	2f e7       	ldi	r18, 0x7F	; 127
    21c4:	88 e3       	ldi	r24, 0x38	; 56
    21c6:	91 e0       	ldi	r25, 0x01	; 1
    21c8:	21 50       	subi	r18, 0x01	; 1
    21ca:	80 40       	sbci	r24, 0x00	; 0
    21cc:	90 40       	sbci	r25, 0x00	; 0
    21ce:	e1 f7       	brne	.-8      	; 0x21c8 <setup_and_test+0x80>
    21d0:	00 c0       	rjmp	.+0      	; 0x21d2 <setup_and_test+0x8a>
    21d2:	00 00       	nop
		_delay_ms(50);
		determinar_estados();
    21d4:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
    21d8:	21 96       	adiw	r28, 0x01	; 1
	for(uint8_t i=0;i<9;i++)bastioes[i]=valores[i]-thresholds[i];
}
void setup_and_test(){
	apagar();
	atualizar_display();
	for(uint8_t i=0;i<9;i++){
    21da:	c9 30       	cpi	r28, 0x09	; 9
    21dc:	d1 05       	cpc	r29, r1
    21de:	71 f6       	brne	.-100    	; 0x217c <setup_and_test+0x34>
    21e0:	c0 e0       	ldi	r28, 0x00	; 0
    21e2:	d0 e0       	ldi	r29, 0x00	; 0
		atualizar_display();
		_delay_ms(50);
		determinar_estados();
	}
	for(uint8_t i=0;i<9;i++){
		leds_l[i] = LED_O;
    21e4:	68 94       	set
    21e6:	ff 24       	eor	r15, r15
    21e8:	f1 f8       	bld	r15, 1
#define PRE 150
int16_t valores[9], bastioes[9], thresholds[9]={PRE,100,PRE,PRE,100,PRE,PRE,PRE,PRE};
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
    21ea:	00 e0       	ldi	r16, 0x00	; 0
    21ec:	10 e0       	ldi	r17, 0x00	; 0
		atualizar_display();
		_delay_ms(50);
		determinar_estados();
	}
	for(uint8_t i=0;i<9;i++){
		leds_l[i] = LED_O;
    21ee:	e0 91 12 01 	lds	r30, 0x0112
    21f2:	f0 91 13 01 	lds	r31, 0x0113
    21f6:	ec 0f       	add	r30, r28
    21f8:	fd 1f       	adc	r31, r29
    21fa:	f0 82       	st	Z, r15
		atualizar_display();
    21fc:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    2200:	2f e7       	ldi	r18, 0x7F	; 127
    2202:	88 e3       	ldi	r24, 0x38	; 56
    2204:	91 e0       	ldi	r25, 0x01	; 1
    2206:	21 50       	subi	r18, 0x01	; 1
    2208:	80 40       	sbci	r24, 0x00	; 0
    220a:	90 40       	sbci	r25, 0x00	; 0
    220c:	e1 f7       	brne	.-8      	; 0x2206 <setup_and_test+0xbe>
    220e:	00 c0       	rjmp	.+0      	; 0x2210 <setup_and_test+0xc8>
    2210:	00 00       	nop
		_delay_ms(50);
		determinar_estados();
    2212:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
#define PRE 150
int16_t valores[9], bastioes[9], thresholds[9]={PRE,100,PRE,PRE,100,PRE,PRE,PRE,PRE};
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
    2216:	80 2f       	mov	r24, r16
    2218:	91 2f       	mov	r25, r17
    221a:	e0 91 12 01 	lds	r30, 0x0112
    221e:	f0 91 13 01 	lds	r31, 0x0113
    2222:	e8 0f       	add	r30, r24
    2224:	f9 1f       	adc	r31, r25
    2226:	10 82       	st	Z, r1
    2228:	01 96       	adiw	r24, 0x01	; 1
    222a:	89 30       	cpi	r24, 0x09	; 9
    222c:	91 05       	cpc	r25, r1
    222e:	a9 f7       	brne	.-22     	; 0x221a <setup_and_test+0xd2>
		leds_l[i] = LED_O;
		atualizar_display();
		_delay_ms(50);
		determinar_estados();
		apagar();
		atualizar_display();
    2230:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    2234:	2f e7       	ldi	r18, 0x7F	; 127
    2236:	88 e3       	ldi	r24, 0x38	; 56
    2238:	91 e0       	ldi	r25, 0x01	; 1
    223a:	21 50       	subi	r18, 0x01	; 1
    223c:	80 40       	sbci	r24, 0x00	; 0
    223e:	90 40       	sbci	r25, 0x00	; 0
    2240:	e1 f7       	brne	.-8      	; 0x223a <setup_and_test+0xf2>
    2242:	00 c0       	rjmp	.+0      	; 0x2244 <setup_and_test+0xfc>
    2244:	00 00       	nop
		_delay_ms(50);
		determinar_estados();
    2246:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
    224a:	21 96       	adiw	r28, 0x01	; 1
		apagar();
		atualizar_display();
		_delay_ms(50);
		determinar_estados();
	}
	for(uint8_t i=0;i<9;i++){
    224c:	c9 30       	cpi	r28, 0x09	; 9
    224e:	d1 05       	cpc	r29, r1
    2250:	71 f6       	brne	.-100    	; 0x21ee <setup_and_test+0xa6>
		apagar();
		atualizar_display();
		_delay_ms(50);
		determinar_estados();
	}
}
    2252:	df 91       	pop	r29
    2254:	cf 91       	pop	r28
    2256:	1f 91       	pop	r17
    2258:	0f 91       	pop	r16
    225a:	ff 90       	pop	r15
    225c:	08 95       	ret

0000225e <fazerJogada>:
void fazerJogada(uint8_t posicao, uint8_t jogada){
    225e:	ef 92       	push	r14
    2260:	ff 92       	push	r15
    2262:	0f 93       	push	r16
    2264:	1f 93       	push	r17
    2266:	cf 93       	push	r28
    2268:	df 93       	push	r29
    226a:	f6 2e       	mov	r15, r22
	uint8_t ultima = leds_l[posicao];
    226c:	c8 2f       	mov	r28, r24
    226e:	d0 e0       	ldi	r29, 0x00	; 0
    2270:	e0 91 12 01 	lds	r30, 0x0112
    2274:	f0 91 13 01 	lds	r31, 0x0113
    2278:	ec 0f       	add	r30, r28
    227a:	fd 1f       	adc	r31, r29
    227c:	e0 80       	ld	r14, Z
    227e:	03 e0       	ldi	r16, 0x03	; 3
    2280:	10 e0       	ldi	r17, 0x00	; 0
	for(int i=0;i<3;i++){
		leds_l[posicao] = jogada;
    2282:	e0 91 12 01 	lds	r30, 0x0112
    2286:	f0 91 13 01 	lds	r31, 0x0113
    228a:	ec 0f       	add	r30, r28
    228c:	fd 1f       	adc	r31, r29
    228e:	f0 82       	st	Z, r15
		atualizar_display();
    2290:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    2294:	2f ef       	ldi	r18, 0xFF	; 255
    2296:	80 e7       	ldi	r24, 0x70	; 112
    2298:	92 e0       	ldi	r25, 0x02	; 2
    229a:	21 50       	subi	r18, 0x01	; 1
    229c:	80 40       	sbci	r24, 0x00	; 0
    229e:	90 40       	sbci	r25, 0x00	; 0
    22a0:	e1 f7       	brne	.-8      	; 0x229a <fazerJogada+0x3c>
    22a2:	00 c0       	rjmp	.+0      	; 0x22a4 <fazerJogada+0x46>
    22a4:	00 00       	nop
		_delay_ms(100);
		determinar_estados();
    22a6:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
		leds_l[posicao] = ultima;
    22aa:	e0 91 12 01 	lds	r30, 0x0112
    22ae:	f0 91 13 01 	lds	r31, 0x0113
    22b2:	ec 0f       	add	r30, r28
    22b4:	fd 1f       	adc	r31, r29
    22b6:	e0 82       	st	Z, r14
		atualizar_display();
    22b8:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    22bc:	2f ef       	ldi	r18, 0xFF	; 255
    22be:	80 e7       	ldi	r24, 0x70	; 112
    22c0:	92 e0       	ldi	r25, 0x02	; 2
    22c2:	21 50       	subi	r18, 0x01	; 1
    22c4:	80 40       	sbci	r24, 0x00	; 0
    22c6:	90 40       	sbci	r25, 0x00	; 0
    22c8:	e1 f7       	brne	.-8      	; 0x22c2 <fazerJogada+0x64>
    22ca:	00 c0       	rjmp	.+0      	; 0x22cc <fazerJogada+0x6e>
    22cc:	00 00       	nop
		_delay_ms(100);
		determinar_estados();
    22ce:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
    22d2:	01 50       	subi	r16, 0x01	; 1
    22d4:	11 09       	sbc	r17, r1
		determinar_estados();
	}
}
void fazerJogada(uint8_t posicao, uint8_t jogada){
	uint8_t ultima = leds_l[posicao];
	for(int i=0;i<3;i++){
    22d6:	a9 f6       	brne	.-86     	; 0x2282 <fazerJogada+0x24>
		leds_l[posicao] = ultima;
		atualizar_display();
		_delay_ms(100);
		determinar_estados();
	}
	leds_l[posicao] = jogada;
    22d8:	80 91 12 01 	lds	r24, 0x0112
    22dc:	90 91 13 01 	lds	r25, 0x0113
    22e0:	c8 0f       	add	r28, r24
    22e2:	d9 1f       	adc	r29, r25
    22e4:	f8 82       	st	Y, r15
	atualizar_display();
    22e6:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
	determinar_estados();
    22ea:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
}
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	1f 91       	pop	r17
    22f4:	0f 91       	pop	r16
    22f6:	ff 90       	pop	r15
    22f8:	ef 90       	pop	r14
    22fa:	08 95       	ret

000022fc <esperarJogada>:
uint8_t esperarJogada(int32_t timeout){
    22fc:	4f 92       	push	r4
    22fe:	5f 92       	push	r5
    2300:	6f 92       	push	r6
    2302:	7f 92       	push	r7
    2304:	8f 92       	push	r8
    2306:	9f 92       	push	r9
    2308:	af 92       	push	r10
    230a:	bf 92       	push	r11
    230c:	cf 92       	push	r12
    230e:	df 92       	push	r13
    2310:	ef 92       	push	r14
    2312:	ff 92       	push	r15
    2314:	0f 93       	push	r16
    2316:	1f 93       	push	r17
    2318:	cf 93       	push	r28
    231a:	df 93       	push	r29
    231c:	cd b7       	in	r28, 0x3d	; 61
    231e:	de b7       	in	r29, 0x3e	; 62
    2320:	29 97       	sbiw	r28, 0x09	; 9
    2322:	0f b6       	in	r0, 0x3f	; 63
    2324:	f8 94       	cli
    2326:	de bf       	out	0x3e, r29	; 62
    2328:	0f be       	out	0x3f, r0	; 63
    232a:	cd bf       	out	0x3d, r28	; 61
    232c:	4b 01       	movw	r8, r22
    232e:	5c 01       	movw	r10, r24
	uint8_t ultimos_estados[9], i;
	determinar_estados();
    2330:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
    2334:	20 e3       	ldi	r18, 0x30	; 48
    2336:	31 e0       	ldi	r19, 0x01	; 1
    2338:	ce 01       	movw	r24, r28
    233a:	01 96       	adiw	r24, 0x01	; 1
    233c:	7c 01       	movw	r14, r24
    233e:	09 e3       	ldi	r16, 0x39	; 57
    2340:	11 e0       	ldi	r17, 0x01	; 1
    2342:	dc 01       	movw	r26, r24
    2344:	f9 01       	movw	r30, r18
	for(i=0;i<9;i++)ultimos_estados[i]=estados[i];
    2346:	81 91       	ld	r24, Z+
    2348:	8d 93       	st	X+, r24
    234a:	e0 17       	cp	r30, r16
    234c:	f1 07       	cpc	r31, r17
    234e:	d9 f7       	brne	.-10     	; 0x2346 <esperarJogada+0x4a>
	while(timeout>0){
    2350:	18 14       	cp	r1, r8
    2352:	19 04       	cpc	r1, r9
    2354:	1a 04       	cpc	r1, r10
    2356:	1b 04       	cpc	r1, r11
    2358:	c4 f5       	brge	.+112    	; 0x23ca <esperarJogada+0xce>
    235a:	6e 01       	movw	r12, r28
    235c:	9a e0       	ldi	r25, 0x0A	; 10
    235e:	c9 0e       	add	r12, r25
    2360:	d1 1c       	adc	r13, r1
		determinar_estados();
    2362:	4e 2c       	mov	r4, r14
    2364:	5f 2c       	mov	r5, r15
    2366:	62 2e       	mov	r6, r18
    2368:	73 2e       	mov	r7, r19
    236a:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <determinar_estados>
    236e:	e4 2d       	mov	r30, r4
    2370:	f5 2d       	mov	r31, r5
    2372:	a6 2d       	mov	r26, r6
    2374:	b7 2d       	mov	r27, r7
    2376:	8e 2f       	mov	r24, r30
    2378:	8e 19       	sub	r24, r14
		for(i=0;i<9;i++){
			if(estados[i]&&!ultimos_estados[i])return i;
    237a:	9d 91       	ld	r25, X+
    237c:	99 23       	and	r25, r25
    237e:	19 f0       	breq	.+6      	; 0x2386 <esperarJogada+0x8a>
    2380:	90 81       	ld	r25, Z
    2382:	99 23       	and	r25, r25
    2384:	19 f1       	breq	.+70     	; 0x23cc <esperarJogada+0xd0>
    2386:	31 96       	adiw	r30, 0x01	; 1
	uint8_t ultimos_estados[9], i;
	determinar_estados();
	for(i=0;i<9;i++)ultimos_estados[i]=estados[i];
	while(timeout>0){
		determinar_estados();
		for(i=0;i<9;i++){
    2388:	ec 15       	cp	r30, r12
    238a:	fd 05       	cpc	r31, r13
    238c:	a1 f7       	brne	.-24     	; 0x2376 <esperarJogada+0x7a>
    238e:	a4 2d       	mov	r26, r4
    2390:	b5 2d       	mov	r27, r5
    2392:	e6 2d       	mov	r30, r6
    2394:	f7 2d       	mov	r31, r7
			if(estados[i]&&!ultimos_estados[i])return i;
		}
		for(uint8_t i=0;i<9;i++)ultimos_estados[i]=estados[i];
    2396:	81 91       	ld	r24, Z+
    2398:	8d 93       	st	X+, r24
    239a:	e0 17       	cp	r30, r16
    239c:	f1 07       	cpc	r31, r17
    239e:	d9 f7       	brne	.-10     	; 0x2396 <esperarJogada+0x9a>
    23a0:	2f e7       	ldi	r18, 0x7F	; 127
    23a2:	88 e3       	ldi	r24, 0x38	; 56
    23a4:	91 e0       	ldi	r25, 0x01	; 1
    23a6:	21 50       	subi	r18, 0x01	; 1
    23a8:	80 40       	sbci	r24, 0x00	; 0
    23aa:	90 40       	sbci	r25, 0x00	; 0
    23ac:	e1 f7       	brne	.-8      	; 0x23a6 <esperarJogada+0xaa>
    23ae:	00 c0       	rjmp	.+0      	; 0x23b0 <esperarJogada+0xb4>
    23b0:	00 00       	nop
		_delay_ms(50);
		timeout -= 55;
    23b2:	27 e3       	ldi	r18, 0x37	; 55
    23b4:	82 1a       	sub	r8, r18
    23b6:	91 08       	sbc	r9, r1
    23b8:	a1 08       	sbc	r10, r1
    23ba:	b1 08       	sbc	r11, r1
}
uint8_t esperarJogada(int32_t timeout){
	uint8_t ultimos_estados[9], i;
	determinar_estados();
	for(i=0;i<9;i++)ultimos_estados[i]=estados[i];
	while(timeout>0){
    23bc:	18 14       	cp	r1, r8
    23be:	19 04       	cpc	r1, r9
    23c0:	1a 04       	cpc	r1, r10
    23c2:	1b 04       	cpc	r1, r11
    23c4:	94 f2       	brlt	.-92     	; 0x236a <esperarJogada+0x6e>
		}
		for(uint8_t i=0;i<9;i++)ultimos_estados[i]=estados[i];
		_delay_ms(50);
		timeout -= 55;
	}
	return 10;
    23c6:	8a e0       	ldi	r24, 0x0A	; 10
    23c8:	01 c0       	rjmp	.+2      	; 0x23cc <esperarJogada+0xd0>
    23ca:	8a e0       	ldi	r24, 0x0A	; 10
}
    23cc:	29 96       	adiw	r28, 0x09	; 9
    23ce:	0f b6       	in	r0, 0x3f	; 63
    23d0:	f8 94       	cli
    23d2:	de bf       	out	0x3e, r29	; 62
    23d4:	0f be       	out	0x3f, r0	; 63
    23d6:	cd bf       	out	0x3d, r28	; 61
    23d8:	df 91       	pop	r29
    23da:	cf 91       	pop	r28
    23dc:	1f 91       	pop	r17
    23de:	0f 91       	pop	r16
    23e0:	ff 90       	pop	r15
    23e2:	ef 90       	pop	r14
    23e4:	df 90       	pop	r13
    23e6:	cf 90       	pop	r12
    23e8:	bf 90       	pop	r11
    23ea:	af 90       	pop	r10
    23ec:	9f 90       	pop	r9
    23ee:	8f 90       	pop	r8
    23f0:	7f 90       	pop	r7
    23f2:	6f 90       	pop	r6
    23f4:	5f 90       	pop	r5
    23f6:	4f 90       	pop	r4
    23f8:	08 95       	ret

000023fa <checa_vencedor>:
#include "jogadas.h"

const uint8_t vencedoras[9][3] = {{0,0,0},{0,1,2},{3,4,5},{6,7,8},{0,3,6},{1,4,7},{2,5,8},{0,4,8},{2,4,6}};
uint8_t checa_vencedor(){
	for(uint8_t i=1;i<9;i++)
		if(leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][1]] && leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][2]] && leds_l[vencedoras[i][0]]!=0)return i;
    23fa:	20 91 12 01 	lds	r18, 0x0112
    23fe:	30 91 13 01 	lds	r19, 0x0113
    2402:	e9 e1       	ldi	r30, 0x19	; 25
    2404:	f1 e0       	ldi	r31, 0x01	; 1
#include "hardware.h"
#include "jogadas.h"

const uint8_t vencedoras[9][3] = {{0,0,0},{0,1,2},{3,4,5},{6,7,8},{0,3,6},{1,4,7},{2,5,8},{0,4,8},{2,4,6}};
uint8_t checa_vencedor(){
	for(uint8_t i=1;i<9;i++)
    2406:	81 e0       	ldi	r24, 0x01	; 1
    2408:	df 01       	movw	r26, r30
    240a:	12 97       	sbiw	r26, 0x02	; 2
		if(leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][1]] && leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][2]] && leds_l[vencedoras[i][0]]!=0)return i;
    240c:	9c 91       	ld	r25, X
    240e:	d9 01       	movw	r26, r18
    2410:	a9 0f       	add	r26, r25
    2412:	b1 1d       	adc	r27, r1
    2414:	9c 91       	ld	r25, X
    2416:	df 01       	movw	r26, r30
    2418:	11 97       	sbiw	r26, 0x01	; 1
    241a:	4c 91       	ld	r20, X
    241c:	d9 01       	movw	r26, r18
    241e:	a4 0f       	add	r26, r20
    2420:	b1 1d       	adc	r27, r1
    2422:	4c 91       	ld	r20, X
    2424:	94 13       	cpse	r25, r20
    2426:	09 c0       	rjmp	.+18     	; 0x243a <checa_vencedor+0x40>
    2428:	40 81       	ld	r20, Z
    242a:	d9 01       	movw	r26, r18
    242c:	a4 0f       	add	r26, r20
    242e:	b1 1d       	adc	r27, r1
    2430:	4c 91       	ld	r20, X
    2432:	94 13       	cpse	r25, r20
    2434:	02 c0       	rjmp	.+4      	; 0x243a <checa_vencedor+0x40>
    2436:	91 11       	cpse	r25, r1
    2438:	05 c0       	rjmp	.+10     	; 0x2444 <checa_vencedor+0x4a>
#include "hardware.h"
#include "jogadas.h"

const uint8_t vencedoras[9][3] = {{0,0,0},{0,1,2},{3,4,5},{6,7,8},{0,3,6},{1,4,7},{2,5,8},{0,4,8},{2,4,6}};
uint8_t checa_vencedor(){
	for(uint8_t i=1;i<9;i++)
    243a:	8f 5f       	subi	r24, 0xFF	; 255
    243c:	33 96       	adiw	r30, 0x03	; 3
    243e:	89 30       	cpi	r24, 0x09	; 9
    2440:	19 f7       	brne	.-58     	; 0x2408 <checa_vencedor+0xe>
		if(leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][1]] && leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][2]] && leds_l[vencedoras[i][0]]!=0)return i;
	return 0;
    2442:	80 e0       	ldi	r24, 0x00	; 0
}
    2444:	08 95       	ret

00002446 <pisca_vencedor>:
void pisca_vencedor(){
    2446:	8f 92       	push	r8
    2448:	9f 92       	push	r9
    244a:	bf 92       	push	r11
    244c:	cf 92       	push	r12
    244e:	df 92       	push	r13
    2450:	ef 92       	push	r14
    2452:	ff 92       	push	r15
    2454:	0f 93       	push	r16
    2456:	1f 93       	push	r17
    2458:	cf 93       	push	r28
    245a:	df 93       	push	r29
    245c:	cd b7       	in	r28, 0x3d	; 61
    245e:	de b7       	in	r29, 0x3e	; 62
    2460:	62 97       	sbiw	r28, 0x12	; 18
    2462:	0f b6       	in	r0, 0x3f	; 63
    2464:	f8 94       	cli
    2466:	de bf       	out	0x3e, r29	; 62
    2468:	0f be       	out	0x3f, r0	; 63
    246a:	cd bf       	out	0x3d, r28	; 61
	uint8_t original[9],sobreposta[9], i, p, j;
	for(i=0;i<9;i++){
		original[i]=leds_l[i];
    246c:	e0 91 12 01 	lds	r30, 0x0112
    2470:	f0 91 13 01 	lds	r31, 0x0113
    2474:	ce 01       	movw	r24, r28
    2476:	01 96       	adiw	r24, 0x01	; 1
    2478:	4c 01       	movw	r8, r24
    247a:	7e 01       	movw	r14, r28
    247c:	9a e0       	ldi	r25, 0x0A	; 10
    247e:	e9 0e       	add	r14, r25
    2480:	f1 1c       	adc	r15, r1
    2482:	af 01       	movw	r20, r30
    2484:	47 5f       	subi	r20, 0xF7	; 247
    2486:	5f 4f       	sbci	r21, 0xFF	; 255
    2488:	97 01       	movw	r18, r14
    248a:	b4 01       	movw	r22, r8
    248c:	81 91       	ld	r24, Z+
    248e:	db 01       	movw	r26, r22
    2490:	8d 93       	st	X+, r24
    2492:	bd 01       	movw	r22, r26
		sobreposta[i]=leds_l[i];
    2494:	d9 01       	movw	r26, r18
    2496:	8d 93       	st	X+, r24
    2498:	9d 01       	movw	r18, r26
		if(leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][1]] && leds_l[vencedoras[i][0]]==leds_l[vencedoras[i][2]] && leds_l[vencedoras[i][0]]!=0)return i;
	return 0;
}
void pisca_vencedor(){
	uint8_t original[9],sobreposta[9], i, p, j;
	for(i=0;i<9;i++){
    249a:	e4 17       	cp	r30, r20
    249c:	f5 07       	cpc	r31, r21
    249e:	b1 f7       	brne	.-20     	; 0x248c <pisca_vencedor+0x46>
		original[i]=leds_l[i];
		sobreposta[i]=leds_l[i];
	}
	p = checa_vencedor();
    24a0:	0e 94 fd 11 	call	0x23fa	; 0x23fa <checa_vencedor>
	if(p==0)for(i=0;i<9;i++)sobreposta[i]=0;
    24a4:	81 11       	cpse	r24, r1
    24a6:	08 c0       	rjmp	.+16     	; 0x24b8 <pisca_vencedor+0x72>
    24a8:	9e 01       	movw	r18, r28
    24aa:	2d 5e       	subi	r18, 0xED	; 237
    24ac:	3f 4f       	sbci	r19, 0xFF	; 255
    24ae:	f7 01       	movw	r30, r14
    24b0:	11 92       	st	Z+, r1
    24b2:	e2 17       	cp	r30, r18
    24b4:	f3 07       	cpc	r31, r19
    24b6:	e1 f7       	brne	.-8      	; 0x24b0 <pisca_vencedor+0x6a>
	sobreposta[vencedoras[p][0]]=0;
    24b8:	90 e0       	ldi	r25, 0x00	; 0
    24ba:	fc 01       	movw	r30, r24
    24bc:	ee 0f       	add	r30, r30
    24be:	ff 1f       	adc	r31, r31
    24c0:	8e 0f       	add	r24, r30
    24c2:	9f 1f       	adc	r25, r31
    24c4:	fc 01       	movw	r30, r24
    24c6:	ec 5e       	subi	r30, 0xEC	; 236
    24c8:	fe 4f       	sbci	r31, 0xFE	; 254
    24ca:	80 81       	ld	r24, Z
    24cc:	aa e0       	ldi	r26, 0x0A	; 10
    24ce:	b0 e0       	ldi	r27, 0x00	; 0
    24d0:	ac 0f       	add	r26, r28
    24d2:	bd 1f       	adc	r27, r29
    24d4:	a8 0f       	add	r26, r24
    24d6:	b1 1d       	adc	r27, r1
    24d8:	1c 92       	st	X, r1
	sobreposta[vencedoras[p][1]]=0;
    24da:	81 81       	ldd	r24, Z+1	; 0x01
    24dc:	aa e0       	ldi	r26, 0x0A	; 10
    24de:	b0 e0       	ldi	r27, 0x00	; 0
    24e0:	ac 0f       	add	r26, r28
    24e2:	bd 1f       	adc	r27, r29
    24e4:	a8 0f       	add	r26, r24
    24e6:	b1 1d       	adc	r27, r1
    24e8:	1c 92       	st	X, r1
	sobreposta[vencedoras[p][2]]=0;
    24ea:	82 81       	ldd	r24, Z+2	; 0x02
    24ec:	ea e0       	ldi	r30, 0x0A	; 10
    24ee:	f0 e0       	ldi	r31, 0x00	; 0
    24f0:	ec 0f       	add	r30, r28
    24f2:	fd 1f       	adc	r31, r29
    24f4:	e8 0f       	add	r30, r24
    24f6:	f1 1d       	adc	r31, r1
    24f8:	10 82       	st	Z, r1
    24fa:	15 e0       	ldi	r17, 0x05	; 5
	for(i=0;i<9;i++){
		original[i]=leds_l[i];
		sobreposta[i]=leds_l[i];
	}
	p = checa_vencedor();
	if(p==0)for(i=0;i<9;i++)sobreposta[i]=0;
    24fc:	be 2c       	mov	r11, r14
    24fe:	cf 2c       	mov	r12, r15
    2500:	f1 2c       	mov	r15, r1
    2502:	00 e0       	ldi	r16, 0x00	; 0
    2504:	d8 2c       	mov	r13, r8
    2506:	e9 2c       	mov	r14, r9
    2508:	34 c0       	rjmp	.+104    	; 0x2572 <pisca_vencedor+0x12c>
	sobreposta[vencedoras[p][0]]=0;
	sobreposta[vencedoras[p][1]]=0;
	sobreposta[vencedoras[p][2]]=0;
	for(j=0;j<5;j++){
		for(i=0;i<9;i++)leds_l[i]=sobreposta[i];
    250a:	2d 91       	ld	r18, X+
    250c:	e0 91 12 01 	lds	r30, 0x0112
    2510:	f0 91 13 01 	lds	r31, 0x0113
    2514:	e8 0f       	add	r30, r24
    2516:	f9 1f       	adc	r31, r25
    2518:	20 83       	st	Z, r18
    251a:	01 96       	adiw	r24, 0x01	; 1
    251c:	89 30       	cpi	r24, 0x09	; 9
    251e:	91 05       	cpc	r25, r1
    2520:	a1 f7       	brne	.-24     	; 0x250a <pisca_vencedor+0xc4>
		atualizar_display();
    2522:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    2526:	bf ef       	ldi	r27, 0xFF	; 255
    2528:	21 ee       	ldi	r18, 0xE1	; 225
    252a:	84 e0       	ldi	r24, 0x04	; 4
    252c:	b1 50       	subi	r27, 0x01	; 1
    252e:	20 40       	sbci	r18, 0x00	; 0
    2530:	80 40       	sbci	r24, 0x00	; 0
    2532:	e1 f7       	brne	.-8      	; 0x252c <pisca_vencedor+0xe6>
    2534:	00 c0       	rjmp	.+0      	; 0x2536 <pisca_vencedor+0xf0>
    2536:	00 00       	nop
    2538:	ad 2d       	mov	r26, r13
    253a:	be 2d       	mov	r27, r14
    253c:	8f 2d       	mov	r24, r15
    253e:	90 2f       	mov	r25, r16
		_delay_ms(200);
		for(i=0;i<9;i++)leds_l[i]=original[i];
    2540:	2d 91       	ld	r18, X+
    2542:	e0 91 12 01 	lds	r30, 0x0112
    2546:	f0 91 13 01 	lds	r31, 0x0113
    254a:	e8 0f       	add	r30, r24
    254c:	f9 1f       	adc	r31, r25
    254e:	20 83       	st	Z, r18
    2550:	01 96       	adiw	r24, 0x01	; 1
    2552:	89 30       	cpi	r24, 0x09	; 9
    2554:	91 05       	cpc	r25, r1
    2556:	a1 f7       	brne	.-24     	; 0x2540 <pisca_vencedor+0xfa>
		atualizar_display();
    2558:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
    255c:	9f ef       	ldi	r25, 0xFF	; 255
    255e:	a1 ee       	ldi	r26, 0xE1	; 225
    2560:	b4 e0       	ldi	r27, 0x04	; 4
    2562:	91 50       	subi	r25, 0x01	; 1
    2564:	a0 40       	sbci	r26, 0x00	; 0
    2566:	b0 40       	sbci	r27, 0x00	; 0
    2568:	e1 f7       	brne	.-8      	; 0x2562 <pisca_vencedor+0x11c>
    256a:	00 c0       	rjmp	.+0      	; 0x256c <pisca_vencedor+0x126>
    256c:	00 00       	nop
    256e:	11 50       	subi	r17, 0x01	; 1
	p = checa_vencedor();
	if(p==0)for(i=0;i<9;i++)sobreposta[i]=0;
	sobreposta[vencedoras[p][0]]=0;
	sobreposta[vencedoras[p][1]]=0;
	sobreposta[vencedoras[p][2]]=0;
	for(j=0;j<5;j++){
    2570:	29 f0       	breq	.+10     	; 0x257c <pisca_vencedor+0x136>
	for(i=0;i<9;i++){
		original[i]=leds_l[i];
		sobreposta[i]=leds_l[i];
	}
	p = checa_vencedor();
	if(p==0)for(i=0;i<9;i++)sobreposta[i]=0;
    2572:	ab 2d       	mov	r26, r11
    2574:	bc 2d       	mov	r27, r12
    2576:	8f 2d       	mov	r24, r15
    2578:	90 2f       	mov	r25, r16
    257a:	c7 cf       	rjmp	.-114    	; 0x250a <pisca_vencedor+0xc4>
		_delay_ms(200);
		for(i=0;i<9;i++)leds_l[i]=original[i];
		atualizar_display();
		_delay_ms(200);
	}
}
    257c:	62 96       	adiw	r28, 0x12	; 18
    257e:	0f b6       	in	r0, 0x3f	; 63
    2580:	f8 94       	cli
    2582:	de bf       	out	0x3e, r29	; 62
    2584:	0f be       	out	0x3f, r0	; 63
    2586:	cd bf       	out	0x3d, r28	; 61
    2588:	df 91       	pop	r29
    258a:	cf 91       	pop	r28
    258c:	1f 91       	pop	r17
    258e:	0f 91       	pop	r16
    2590:	ff 90       	pop	r15
    2592:	ef 90       	pop	r14
    2594:	df 90       	pop	r13
    2596:	cf 90       	pop	r12
    2598:	bf 90       	pop	r11
    259a:	9f 90       	pop	r9
    259c:	8f 90       	pop	r8
    259e:	08 95       	ret

000025a0 <jogar2p>:
void jogar2p(){
    25a0:	cf 93       	push	r28
#define PRE 150
int16_t valores[9], bastioes[9], thresholds[9]={PRE,100,PRE,PRE,100,PRE,PRE,PRE,PRE};
uint8_t estados[9];

inline void apagar(){
	for(int i=0;i<9;i++)leds_l[i]=0;
    25a2:	80 e0       	ldi	r24, 0x00	; 0
    25a4:	90 e0       	ldi	r25, 0x00	; 0
    25a6:	e0 91 12 01 	lds	r30, 0x0112
    25aa:	f0 91 13 01 	lds	r31, 0x0113
    25ae:	e8 0f       	add	r30, r24
    25b0:	f9 1f       	adc	r31, r25
    25b2:	10 82       	st	Z, r1
    25b4:	01 96       	adiw	r24, 0x01	; 1
    25b6:	89 30       	cpi	r24, 0x09	; 9
    25b8:	91 05       	cpc	r25, r1
    25ba:	a9 f7       	brne	.-22     	; 0x25a6 <jogar2p+0x6>
	uint8_t jogador, jogada;
	apagar();
	atualizar_display();
    25bc:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
	for(jogador=0;jogador<9;jogador++){
    25c0:	c0 e0       	ldi	r28, 0x00	; 0
		jogada = esperarJogada(120000);
    25c2:	60 ec       	ldi	r22, 0xC0	; 192
    25c4:	74 ed       	ldi	r23, 0xD4	; 212
    25c6:	81 e0       	ldi	r24, 0x01	; 1
    25c8:	90 e0       	ldi	r25, 0x00	; 0
    25ca:	0e 94 7e 11 	call	0x22fc	; 0x22fc <esperarJogada>
		if(jogada>9){
    25ce:	8a 30       	cpi	r24, 0x0A	; 10
    25d0:	18 f0       	brcs	.+6      	; 0x25d8 <jogar2p+0x38>
			pisca_vencedor();
    25d2:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
			return;
    25d6:	20 c0       	rjmp	.+64     	; 0x2618 <jogar2p+0x78>
		}
		if(leds_l[jogada]){
    25d8:	e0 91 12 01 	lds	r30, 0x0112
    25dc:	f0 91 13 01 	lds	r31, 0x0113
    25e0:	e8 0f       	add	r30, r24
    25e2:	f1 1d       	adc	r31, r1
    25e4:	90 81       	ld	r25, Z
    25e6:	99 23       	and	r25, r25
    25e8:	11 f0       	breq	.+4      	; 0x25ee <jogar2p+0x4e>
			jogador--;
    25ea:	c1 50       	subi	r28, 0x01	; 1
    25ec:	10 c0       	rjmp	.+32     	; 0x260e <jogar2p+0x6e>
		}else{
			if(jogador&1)fazerJogada(jogada,LED_O);
    25ee:	c0 ff       	sbrs	r28, 0
    25f0:	04 c0       	rjmp	.+8      	; 0x25fa <jogar2p+0x5a>
    25f2:	62 e0       	ldi	r22, 0x02	; 2
    25f4:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
    25f8:	03 c0       	rjmp	.+6      	; 0x2600 <jogar2p+0x60>
			else         fazerJogada(jogada,LED_X);
    25fa:	61 e0       	ldi	r22, 0x01	; 1
    25fc:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
			if(checa_vencedor()){
    2600:	0e 94 fd 11 	call	0x23fa	; 0x23fa <checa_vencedor>
    2604:	88 23       	and	r24, r24
    2606:	19 f0       	breq	.+6      	; 0x260e <jogar2p+0x6e>
				pisca_vencedor();
    2608:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
				return;
    260c:	05 c0       	rjmp	.+10     	; 0x2618 <jogar2p+0x78>
}
void jogar2p(){
	uint8_t jogador, jogada;
	apagar();
	atualizar_display();
	for(jogador=0;jogador<9;jogador++){
    260e:	cf 5f       	subi	r28, 0xFF	; 255
    2610:	c9 30       	cpi	r28, 0x09	; 9
    2612:	b8 f2       	brcs	.-82     	; 0x25c2 <jogar2p+0x22>
				pisca_vencedor();
				return;
			}
		}
	}
	pisca_vencedor();
    2614:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
	return;
}
    2618:	cf 91       	pop	r28
    261a:	08 95       	ret

0000261c <jogar1p>:
//uma vez que no  possivel fazer a 10 jogada, logo, somente  necessrio o conhecimento de apenas 4 jogadas
//#include "jogadas.h"
//com isso, para jogar, ser feito o seguinte: o jogador joga,  checado (apezar de em vo) a vitria (ou o empate)
//ento com as jogadas anteriores, o uC joga,  testado para ver se venceu (ou empatou)

void jogar1p(){
    261c:	af 92       	push	r10
    261e:	bf 92       	push	r11
    2620:	df 92       	push	r13
    2622:	ef 92       	push	r14
    2624:	ff 92       	push	r15
    2626:	0f 93       	push	r16
    2628:	1f 93       	push	r17
    262a:	cf 93       	push	r28
    262c:	df 93       	push	r29
    262e:	80 e0       	ldi	r24, 0x00	; 0
    2630:	90 e0       	ldi	r25, 0x00	; 0
    2632:	e0 91 12 01 	lds	r30, 0x0112
    2636:	f0 91 13 01 	lds	r31, 0x0113
    263a:	e8 0f       	add	r30, r24
    263c:	f9 1f       	adc	r31, r25
    263e:	10 82       	st	Z, r1
    2640:	01 96       	adiw	r24, 0x01	; 1
    2642:	89 30       	cpi	r24, 0x09	; 9
    2644:	91 05       	cpc	r25, r1
    2646:	a9 f7       	brne	.-22     	; 0x2632 <jogar1p+0x16>
	uint8_t jogadas[4], jogada;
	apagar();
	atualizar_display();
    2648:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
	do{   ////////////////////////////////////////////////1
		jogada = esperarJogada(120000);
    264c:	60 ec       	ldi	r22, 0xC0	; 192
    264e:	74 ed       	ldi	r23, 0xD4	; 212
    2650:	81 e0       	ldi	r24, 0x01	; 1
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	0e 94 7e 11 	call	0x22fc	; 0x22fc <esperarJogada>
    2658:	c8 2f       	mov	r28, r24
		if(jogada>9){
    265a:	8a 30       	cpi	r24, 0x0A	; 10
    265c:	18 f0       	brcs	.+6      	; 0x2664 <jogar1p+0x48>
			pisca_vencedor();
    265e:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
			return;
    2662:	de c0       	rjmp	.+444    	; 0x2820 <jogar1p+0x204>
		}
	}while(leds_l[jogada]);
    2664:	e0 91 12 01 	lds	r30, 0x0112
    2668:	f0 91 13 01 	lds	r31, 0x0113
    266c:	e8 0f       	add	r30, r24
    266e:	f1 1d       	adc	r31, r1
    2670:	80 81       	ld	r24, Z
    2672:	81 11       	cpse	r24, r1
    2674:	eb cf       	rjmp	.-42     	; 0x264c <jogar1p+0x30>
	fazerJogada(jogada,LED_X);
    2676:	61 e0       	ldi	r22, 0x01	; 1
    2678:	8c 2f       	mov	r24, r28
    267a:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	jogadas[0] = jogada;  ////////////////////////////////2
	jogada = pgm_read_byte( &JOG1[jogadas[0]] ) - 1;
    267e:	d0 e0       	ldi	r29, 0x00	; 0
    2680:	fe 01       	movw	r30, r28
    2682:	ed 5c       	subi	r30, 0xCD	; 205
    2684:	f2 4e       	sbci	r31, 0xE2	; 226
    2686:	84 91       	lpm	r24, Z
	fazerJogada(jogada,LED_O);
    2688:	62 e0       	ldi	r22, 0x02	; 2
    268a:	81 50       	subi	r24, 0x01	; 1
    268c:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	
	do{   ////////////////////////////////////////////////3
		jogada = esperarJogada(120000);
    2690:	60 ec       	ldi	r22, 0xC0	; 192
    2692:	74 ed       	ldi	r23, 0xD4	; 212
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	0e 94 7e 11 	call	0x22fc	; 0x22fc <esperarJogada>
    269c:	08 2f       	mov	r16, r24
		if(jogada>9){
    269e:	8a 30       	cpi	r24, 0x0A	; 10
    26a0:	18 f0       	brcs	.+6      	; 0x26a8 <jogar1p+0x8c>
			pisca_vencedor();
    26a2:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
			return;
    26a6:	bc c0       	rjmp	.+376    	; 0x2820 <jogar1p+0x204>
		}
	}while(leds_l[jogada]);
    26a8:	e0 91 12 01 	lds	r30, 0x0112
    26ac:	f0 91 13 01 	lds	r31, 0x0113
    26b0:	e8 0f       	add	r30, r24
    26b2:	f1 1d       	adc	r31, r1
    26b4:	80 81       	ld	r24, Z
    26b6:	81 11       	cpse	r24, r1
    26b8:	eb cf       	rjmp	.-42     	; 0x2690 <jogar1p+0x74>
	fazerJogada(jogada,LED_X);
    26ba:	61 e0       	ldi	r22, 0x01	; 1
    26bc:	80 2f       	mov	r24, r16
    26be:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	jogadas[1] = jogada;  ////////////////////////////////4
	jogada = pgm_read_byte( &JOG2[jogadas[0]][jogadas[1]] ) - 1;
    26c2:	a0 2e       	mov	r10, r16
    26c4:	b1 2c       	mov	r11, r1
    26c6:	fe 01       	movw	r30, r28
    26c8:	ee 0f       	add	r30, r30
    26ca:	ff 1f       	adc	r31, r31
    26cc:	ee 0f       	add	r30, r30
    26ce:	ff 1f       	adc	r31, r31
    26d0:	ee 0f       	add	r30, r30
    26d2:	ff 1f       	adc	r31, r31
    26d4:	ec 0f       	add	r30, r28
    26d6:	fd 1f       	adc	r31, r29
    26d8:	ea 0d       	add	r30, r10
    26da:	fb 1d       	adc	r31, r11
    26dc:	ee 51       	subi	r30, 0x1E	; 30
    26de:	f3 4e       	sbci	r31, 0xE3	; 227
    26e0:	84 91       	lpm	r24, Z
	fazerJogada(jogada,LED_O);
    26e2:	62 e0       	ldi	r22, 0x02	; 2
    26e4:	81 50       	subi	r24, 0x01	; 1
    26e6:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	
	do{   ////////////////////////////////////////////////5
		jogada = esperarJogada(120000);
    26ea:	60 ec       	ldi	r22, 0xC0	; 192
    26ec:	74 ed       	ldi	r23, 0xD4	; 212
    26ee:	81 e0       	ldi	r24, 0x01	; 1
    26f0:	90 e0       	ldi	r25, 0x00	; 0
    26f2:	0e 94 7e 11 	call	0x22fc	; 0x22fc <esperarJogada>
    26f6:	18 2f       	mov	r17, r24
		if(jogada>9){
    26f8:	8a 30       	cpi	r24, 0x0A	; 10
    26fa:	18 f0       	brcs	.+6      	; 0x2702 <jogar1p+0xe6>
			pisca_vencedor();
    26fc:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
			return;
    2700:	8f c0       	rjmp	.+286    	; 0x2820 <jogar1p+0x204>
		}
	}while(leds_l[jogada]);
    2702:	e0 91 12 01 	lds	r30, 0x0112
    2706:	f0 91 13 01 	lds	r31, 0x0113
    270a:	e8 0f       	add	r30, r24
    270c:	f1 1d       	adc	r31, r1
    270e:	80 81       	ld	r24, Z
    2710:	81 11       	cpse	r24, r1
    2712:	eb cf       	rjmp	.-42     	; 0x26ea <jogar1p+0xce>
	fazerJogada(jogada,LED_X);
    2714:	61 e0       	ldi	r22, 0x01	; 1
    2716:	81 2f       	mov	r24, r17
    2718:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	jogadas[2] = jogada;  ////////////////////////////////6
	jogada = pgm_read_byte( &JOG3[jogadas[0]][jogadas[1]][jogadas[2]] ) - 1;
    271c:	e1 2e       	mov	r14, r17
    271e:	f1 2c       	mov	r15, r1
    2720:	f5 01       	movw	r30, r10
    2722:	ee 0f       	add	r30, r30
    2724:	ff 1f       	adc	r31, r31
    2726:	ee 0f       	add	r30, r30
    2728:	ff 1f       	adc	r31, r31
    272a:	ee 0f       	add	r30, r30
    272c:	ff 1f       	adc	r31, r31
    272e:	ea 0d       	add	r30, r10
    2730:	fb 1d       	adc	r31, r11
    2732:	21 e5       	ldi	r18, 0x51	; 81
    2734:	2c 9f       	mul	r18, r28
    2736:	c0 01       	movw	r24, r0
    2738:	2d 9f       	mul	r18, r29
    273a:	90 0d       	add	r25, r0
    273c:	11 24       	eor	r1, r1
    273e:	e8 0f       	add	r30, r24
    2740:	f9 1f       	adc	r31, r25
    2742:	ee 0d       	add	r30, r14
    2744:	ff 1d       	adc	r31, r15
    2746:	e7 5f       	subi	r30, 0xF7	; 247
    2748:	f5 4e       	sbci	r31, 0xE5	; 229
    274a:	84 91       	lpm	r24, Z
	fazerJogada(jogada,LED_O);
    274c:	62 e0       	ldi	r22, 0x02	; 2
    274e:	81 50       	subi	r24, 0x01	; 1
    2750:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	if(checa_vencedor()){
    2754:	0e 94 fd 11 	call	0x23fa	; 0x23fa <checa_vencedor>
    2758:	88 23       	and	r24, r24
    275a:	19 f0       	breq	.+6      	; 0x2762 <jogar1p+0x146>
		pisca_vencedor();
    275c:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
		return;
    2760:	5f c0       	rjmp	.+190    	; 0x2820 <jogar1p+0x204>
	}
	
	do{   ////////////////////////////////////////////////7
		jogada = esperarJogada(120000);
    2762:	60 ec       	ldi	r22, 0xC0	; 192
    2764:	74 ed       	ldi	r23, 0xD4	; 212
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	0e 94 7e 11 	call	0x22fc	; 0x22fc <esperarJogada>
    276e:	d8 2e       	mov	r13, r24
		if(jogada>9){
    2770:	89 e0       	ldi	r24, 0x09	; 9
    2772:	8d 15       	cp	r24, r13
    2774:	18 f4       	brcc	.+6      	; 0x277c <jogar1p+0x160>
			pisca_vencedor();
    2776:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
			return;
    277a:	52 c0       	rjmp	.+164    	; 0x2820 <jogar1p+0x204>
		}
	}while(leds_l[jogada]);
    277c:	e0 91 12 01 	lds	r30, 0x0112
    2780:	f0 91 13 01 	lds	r31, 0x0113
    2784:	ed 0d       	add	r30, r13
    2786:	f1 1d       	adc	r31, r1
    2788:	80 81       	ld	r24, Z
    278a:	81 11       	cpse	r24, r1
    278c:	ea cf       	rjmp	.-44     	; 0x2762 <jogar1p+0x146>
	fazerJogada(jogada,LED_X);
    278e:	61 e0       	ldi	r22, 0x01	; 1
    2790:	8d 2d       	mov	r24, r13
    2792:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	jogadas[3] = jogada;  ////////////////////////////////8
	jogada = pgm_read_byte( &JOG4[jogadas[0]][jogadas[1]][jogadas[2]][jogadas[3]] ) - 1;
    2796:	c7 01       	movw	r24, r14
    2798:	88 0f       	add	r24, r24
    279a:	99 1f       	adc	r25, r25
    279c:	88 0f       	add	r24, r24
    279e:	99 1f       	adc	r25, r25
    27a0:	88 0f       	add	r24, r24
    27a2:	99 1f       	adc	r25, r25
    27a4:	e8 0e       	add	r14, r24
    27a6:	f9 1e       	adc	r15, r25
    27a8:	81 e5       	ldi	r24, 0x51	; 81
    27aa:	8a 9d       	mul	r24, r10
    27ac:	f0 01       	movw	r30, r0
    27ae:	8b 9d       	mul	r24, r11
    27b0:	f0 0d       	add	r31, r0
    27b2:	11 24       	eor	r1, r1
    27b4:	ee 0d       	add	r30, r14
    27b6:	ff 1d       	adc	r31, r15
    27b8:	ed 0d       	add	r30, r13
    27ba:	f1 1d       	adc	r31, r1
    27bc:	29 ed       	ldi	r18, 0xD9	; 217
    27be:	32 e0       	ldi	r19, 0x02	; 2
    27c0:	c2 9f       	mul	r28, r18
    27c2:	c0 01       	movw	r24, r0
    27c4:	c3 9f       	mul	r28, r19
    27c6:	90 0d       	add	r25, r0
    27c8:	d2 9f       	mul	r29, r18
    27ca:	90 0d       	add	r25, r0
    27cc:	11 24       	eor	r1, r1
    27ce:	e8 0f       	add	r30, r24
    27d0:	f9 1f       	adc	r31, r25
    27d2:	e8 59       	subi	r30, 0x98	; 152
    27d4:	ff 4f       	sbci	r31, 0xFF	; 255
    27d6:	84 91       	lpm	r24, Z
	fazerJogada(jogada,LED_O);
    27d8:	62 e0       	ldi	r22, 0x02	; 2
    27da:	81 50       	subi	r24, 0x01	; 1
    27dc:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	if(checa_vencedor()){
    27e0:	0e 94 fd 11 	call	0x23fa	; 0x23fa <checa_vencedor>
    27e4:	88 23       	and	r24, r24
    27e6:	19 f0       	breq	.+6      	; 0x27ee <jogar1p+0x1d2>
		pisca_vencedor();
    27e8:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
		return;
    27ec:	19 c0       	rjmp	.+50     	; 0x2820 <jogar1p+0x204>
	}
	
	do{   ////////////////////////////////////////////////9
		jogada = esperarJogada(120000);
    27ee:	60 ec       	ldi	r22, 0xC0	; 192
    27f0:	74 ed       	ldi	r23, 0xD4	; 212
    27f2:	81 e0       	ldi	r24, 0x01	; 1
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	0e 94 7e 11 	call	0x22fc	; 0x22fc <esperarJogada>
		if(jogada>9){
    27fa:	8a 30       	cpi	r24, 0x0A	; 10
    27fc:	18 f0       	brcs	.+6      	; 0x2804 <jogar1p+0x1e8>
			pisca_vencedor();
    27fe:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
			return;
    2802:	0e c0       	rjmp	.+28     	; 0x2820 <jogar1p+0x204>
		}
	}while(leds_l[jogada]);
    2804:	e0 91 12 01 	lds	r30, 0x0112
    2808:	f0 91 13 01 	lds	r31, 0x0113
    280c:	e8 0f       	add	r30, r24
    280e:	f1 1d       	adc	r31, r1
    2810:	90 81       	ld	r25, Z
    2812:	91 11       	cpse	r25, r1
    2814:	ec cf       	rjmp	.-40     	; 0x27ee <jogar1p+0x1d2>
	fazerJogada(jogada,LED_X);
    2816:	61 e0       	ldi	r22, 0x01	; 1
    2818:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
	pisca_vencedor();
    281c:	0e 94 23 12 	call	0x2446	; 0x2446 <pisca_vencedor>
}
    2820:	df 91       	pop	r29
    2822:	cf 91       	pop	r28
    2824:	1f 91       	pop	r17
    2826:	0f 91       	pop	r16
    2828:	ff 90       	pop	r15
    282a:	ef 90       	pop	r14
    282c:	df 90       	pop	r13
    282e:	bf 90       	pop	r11
    2830:	af 90       	pop	r10
    2832:	08 95       	ret

00002834 <main>:

int main(void){
	init_hardware();
    2834:	0e 94 3b 10 	call	0x2076	; 0x2076 <init_hardware>
	setup_and_test();
    2838:	0e 94 a4 10 	call	0x2148	; 0x2148 <setup_and_test>
    283c:	e1 2c       	mov	r14, r1
    283e:	f1 2c       	mov	r15, r1
	while (1){
		apagar();
		leds[1][0] = LED_O|LED_X;
    2840:	c9 e3       	ldi	r28, 0x39	; 57
    2842:	d1 e0       	ldi	r29, 0x01	; 1
    2844:	0f 2e       	mov	r0, r31
    2846:	f3 e0       	ldi	r31, 0x03	; 3
    2848:	df 2e       	mov	r13, r31
    284a:	f0 2d       	mov	r31, r0
    284c:	0d 2d       	mov	r16, r13
		leds[1][2] = LED_X;
    284e:	11 e0       	ldi	r17, 0x01	; 1
    2850:	2e 2d       	mov	r18, r14
    2852:	3f 2d       	mov	r19, r15
    2854:	e0 91 12 01 	lds	r30, 0x0112
    2858:	f0 91 13 01 	lds	r31, 0x0113
    285c:	e2 0f       	add	r30, r18
    285e:	f3 1f       	adc	r31, r19
    2860:	10 82       	st	Z, r1
    2862:	2f 5f       	subi	r18, 0xFF	; 255
    2864:	3f 4f       	sbci	r19, 0xFF	; 255
    2866:	29 30       	cpi	r18, 0x09	; 9
    2868:	31 05       	cpc	r19, r1
    286a:	a1 f7       	brne	.-24     	; 0x2854 <main+0x20>
int main(void){
	init_hardware();
	setup_and_test();
	while (1){
		apagar();
		leds[1][0] = LED_O|LED_X;
    286c:	0b 83       	std	Y+3, r16	; 0x03
		leds[1][2] = LED_X;
    286e:	1d 83       	std	Y+5, r17	; 0x05
		atualizar_display();
    2870:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <atualizar_display>
		uint8_t jogada = esperarJogada(10000);
    2874:	60 e1       	ldi	r22, 0x10	; 16
    2876:	77 e2       	ldi	r23, 0x27	; 39
    2878:	80 e0       	ldi	r24, 0x00	; 0
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	0e 94 7e 11 	call	0x22fc	; 0x22fc <esperarJogada>
		if(jogada==3){
    2880:	83 30       	cpi	r24, 0x03	; 3
    2882:	39 f4       	brne	.+14     	; 0x2892 <main+0x5e>
			fazerJogada(3,0);
    2884:	60 e0       	ldi	r22, 0x00	; 0
    2886:	8d 2d       	mov	r24, r13
    2888:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
			jogar2p();
    288c:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <jogar2p>
    2890:	df cf       	rjmp	.-66     	; 0x2850 <main+0x1c>
		}else if(jogada==5){
    2892:	85 30       	cpi	r24, 0x05	; 5
    2894:	e9 f6       	brne	.-70     	; 0x2850 <main+0x1c>
			fazerJogada(5,0);	
    2896:	60 e0       	ldi	r22, 0x00	; 0
    2898:	0e 94 2f 11 	call	0x225e	; 0x225e <fazerJogada>
			jogar1p();
    289c:	0e 94 0e 13 	call	0x261c	; 0x261c <jogar1p>
    28a0:	d7 cf       	rjmp	.-82     	; 0x2850 <main+0x1c>

000028a2 <_exit>:
    28a2:	f8 94       	cli

000028a4 <__stop_program>:
    28a4:	ff cf       	rjmp	.-2      	; 0x28a4 <__stop_program>
